{-
   Indexes REST API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.1
   Indexes REST API API version: v1
   Contact: support@apibricks.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : IndexesREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module IndexesREST.Model where

import IndexesREST.Core
import IndexesREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** EnabledOnly
newtype EnabledOnly = EnabledOnly { unEnabledOnly :: Bool } deriving (P.Eq, P.Show)

-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- ** FilterAssetId
newtype FilterAssetId = FilterAssetId { unFilterAssetId :: Text } deriving (P.Eq, P.Show)

-- ** FilterExchangeId
newtype FilterExchangeId = FilterExchangeId { unFilterExchangeId :: Text } deriving (P.Eq, P.Show)

-- ** IndexDefinitionId
newtype IndexDefinitionId = IndexDefinitionId { unIndexDefinitionId :: Text } deriving (P.Eq, P.Show)

-- ** IndexId
newtype IndexId = IndexId { unIndexId :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** PendingOnly
newtype PendingOnly = PendingOnly { unPendingOnly :: Bool } deriving (P.Eq, P.Show)

-- ** PeriodId
newtype PeriodId = PeriodId { unPeriodId :: Text } deriving (P.Eq, P.Show)

-- ** Time
newtype Time = Time { unTime :: DateTime } deriving (P.Eq, P.Show)

-- ** TimeEnd
newtype TimeEnd = TimeEnd { unTimeEnd :: DateTime } deriving (P.Eq, P.Show)

-- ** TimeEndText
newtype TimeEndText = TimeEndText { unTimeEndText :: Text } deriving (P.Eq, P.Show)

-- ** TimeStart
newtype TimeStart = TimeStart { unTimeStart :: DateTime } deriving (P.Eq, P.Show)

-- ** TimeStartText
newtype TimeStartText = TimeStartText { unTimeStartText :: Text } deriving (P.Eq, P.Show)

-- ** WithStatusInfo
newtype WithStatusInfo = WithStatusInfo { unWithStatusInfo :: Bool } deriving (P.Eq, P.Show)

-- * Models


-- ** IndexesIndexDefinitionInputData
-- | IndexesIndexDefinitionInputData
data IndexesIndexDefinitionInputData = IndexesIndexDefinitionInputData
  { indexesIndexDefinitionInputDataExchangeId :: !(Maybe Text) -- ^ "exchangeId"
  , indexesIndexDefinitionInputDataExchangeSymbolId :: !(Maybe Text) -- ^ "exchangeSymbolId"
  , indexesIndexDefinitionInputDataBaseAssetId :: !(Maybe Text) -- ^ "baseAssetId"
  , indexesIndexDefinitionInputDataQuoteAssetId :: !(Maybe Text) -- ^ "quoteAssetId"
  , indexesIndexDefinitionInputDataBeginDate :: !(Maybe DateTime) -- ^ "beginDate"
  , indexesIndexDefinitionInputDataEndDate :: !(Maybe DateTime) -- ^ "endDate"
  , indexesIndexDefinitionInputDataStatus :: !(Maybe Text) -- ^ "status"
  , indexesIndexDefinitionInputDataStatusInfo :: !(Maybe Text) -- ^ "statusInfo"
  , indexesIndexDefinitionInputDataLastModificationTime :: !(Maybe DateTime) -- ^ "lastModificationTime"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexDefinitionInputData
instance A.FromJSON IndexesIndexDefinitionInputData where
  parseJSON = A.withObject "IndexesIndexDefinitionInputData" $ \o ->
    IndexesIndexDefinitionInputData
      <$> (o .:? "exchangeId")
      <*> (o .:? "exchangeSymbolId")
      <*> (o .:? "baseAssetId")
      <*> (o .:? "quoteAssetId")
      <*> (o .:? "beginDate")
      <*> (o .:? "endDate")
      <*> (o .:? "status")
      <*> (o .:? "statusInfo")
      <*> (o .:? "lastModificationTime")

-- | ToJSON IndexesIndexDefinitionInputData
instance A.ToJSON IndexesIndexDefinitionInputData where
  toJSON IndexesIndexDefinitionInputData {..} =
   _omitNulls
      [ "exchangeId" .= indexesIndexDefinitionInputDataExchangeId
      , "exchangeSymbolId" .= indexesIndexDefinitionInputDataExchangeSymbolId
      , "baseAssetId" .= indexesIndexDefinitionInputDataBaseAssetId
      , "quoteAssetId" .= indexesIndexDefinitionInputDataQuoteAssetId
      , "beginDate" .= indexesIndexDefinitionInputDataBeginDate
      , "endDate" .= indexesIndexDefinitionInputDataEndDate
      , "status" .= indexesIndexDefinitionInputDataStatus
      , "statusInfo" .= indexesIndexDefinitionInputDataStatusInfo
      , "lastModificationTime" .= indexesIndexDefinitionInputDataLastModificationTime
      ]


-- | Construct a value of type 'IndexesIndexDefinitionInputData' (by applying it's required fields, if any)
mkIndexesIndexDefinitionInputData
  :: IndexesIndexDefinitionInputData
mkIndexesIndexDefinitionInputData =
  IndexesIndexDefinitionInputData
  { indexesIndexDefinitionInputDataExchangeId = Nothing
  , indexesIndexDefinitionInputDataExchangeSymbolId = Nothing
  , indexesIndexDefinitionInputDataBaseAssetId = Nothing
  , indexesIndexDefinitionInputDataQuoteAssetId = Nothing
  , indexesIndexDefinitionInputDataBeginDate = Nothing
  , indexesIndexDefinitionInputDataEndDate = Nothing
  , indexesIndexDefinitionInputDataStatus = Nothing
  , indexesIndexDefinitionInputDataStatusInfo = Nothing
  , indexesIndexDefinitionInputDataLastModificationTime = Nothing
  }

-- ** IndexesIndexDefinitionSnapshotEntry
-- | IndexesIndexDefinitionSnapshotEntry
data IndexesIndexDefinitionSnapshotEntry = IndexesIndexDefinitionSnapshotEntry
  { indexesIndexDefinitionSnapshotEntryIndexId :: !(Maybe Text) -- ^ "index_id"
  , indexesIndexDefinitionSnapshotEntryTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , indexesIndexDefinitionSnapshotEntryValue :: !(Maybe Double) -- ^ "value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexDefinitionSnapshotEntry
instance A.FromJSON IndexesIndexDefinitionSnapshotEntry where
  parseJSON = A.withObject "IndexesIndexDefinitionSnapshotEntry" $ \o ->
    IndexesIndexDefinitionSnapshotEntry
      <$> (o .:? "index_id")
      <*> (o .:? "timestamp")
      <*> (o .:? "value")

-- | ToJSON IndexesIndexDefinitionSnapshotEntry
instance A.ToJSON IndexesIndexDefinitionSnapshotEntry where
  toJSON IndexesIndexDefinitionSnapshotEntry {..} =
   _omitNulls
      [ "index_id" .= indexesIndexDefinitionSnapshotEntryIndexId
      , "timestamp" .= indexesIndexDefinitionSnapshotEntryTimestamp
      , "value" .= indexesIndexDefinitionSnapshotEntryValue
      ]


-- | Construct a value of type 'IndexesIndexDefinitionSnapshotEntry' (by applying it's required fields, if any)
mkIndexesIndexDefinitionSnapshotEntry
  :: IndexesIndexDefinitionSnapshotEntry
mkIndexesIndexDefinitionSnapshotEntry =
  IndexesIndexDefinitionSnapshotEntry
  { indexesIndexDefinitionSnapshotEntryIndexId = Nothing
  , indexesIndexDefinitionSnapshotEntryTimestamp = Nothing
  , indexesIndexDefinitionSnapshotEntryValue = Nothing
  }

-- ** IndexesIndexIdentifier
-- | IndexesIndexIdentifier
-- Represents an index id
data IndexesIndexIdentifier = IndexesIndexIdentifier
  { indexesIndexIdentifierId :: !(Maybe Text) -- ^ "id" - Index ID
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexIdentifier
instance A.FromJSON IndexesIndexIdentifier where
  parseJSON = A.withObject "IndexesIndexIdentifier" $ \o ->
    IndexesIndexIdentifier
      <$> (o .:? "id")

-- | ToJSON IndexesIndexIdentifier
instance A.ToJSON IndexesIndexIdentifier where
  toJSON IndexesIndexIdentifier {..} =
   _omitNulls
      [ "id" .= indexesIndexIdentifierId
      ]


-- | Construct a value of type 'IndexesIndexIdentifier' (by applying it's required fields, if any)
mkIndexesIndexIdentifier
  :: IndexesIndexIdentifier
mkIndexesIndexIdentifier =
  IndexesIndexIdentifier
  { indexesIndexIdentifierId = Nothing
  }

-- ** IndexesIndexMultiAssetWeight
-- | IndexesIndexMultiAssetWeight
data IndexesIndexMultiAssetWeight = IndexesIndexMultiAssetWeight
  { indexesIndexMultiAssetWeightIndexId :: !(Maybe Text) -- ^ "indexId"
  , indexesIndexMultiAssetWeightAssetId :: !(Maybe Text) -- ^ "assetId"
  , indexesIndexMultiAssetWeightWeight :: !(Maybe Double) -- ^ "weight"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexMultiAssetWeight
instance A.FromJSON IndexesIndexMultiAssetWeight where
  parseJSON = A.withObject "IndexesIndexMultiAssetWeight" $ \o ->
    IndexesIndexMultiAssetWeight
      <$> (o .:? "indexId")
      <*> (o .:? "assetId")
      <*> (o .:? "weight")

-- | ToJSON IndexesIndexMultiAssetWeight
instance A.ToJSON IndexesIndexMultiAssetWeight where
  toJSON IndexesIndexMultiAssetWeight {..} =
   _omitNulls
      [ "indexId" .= indexesIndexMultiAssetWeightIndexId
      , "assetId" .= indexesIndexMultiAssetWeightAssetId
      , "weight" .= indexesIndexMultiAssetWeightWeight
      ]


-- | Construct a value of type 'IndexesIndexMultiAssetWeight' (by applying it's required fields, if any)
mkIndexesIndexMultiAssetWeight
  :: IndexesIndexMultiAssetWeight
mkIndexesIndexMultiAssetWeight =
  IndexesIndexMultiAssetWeight
  { indexesIndexMultiAssetWeightIndexId = Nothing
  , indexesIndexMultiAssetWeightAssetId = Nothing
  , indexesIndexMultiAssetWeightWeight = Nothing
  }

-- ** IndexesIndexTimeseriesItem
-- | IndexesIndexTimeseriesItem
-- Represents a timeseries item with value information.
data IndexesIndexTimeseriesItem = IndexesIndexTimeseriesItem
  { indexesIndexTimeseriesItemTimePeriodStart :: !(Maybe DateTime) -- ^ "time_period_start" - Gets or sets the start time of the time period.
  , indexesIndexTimeseriesItemTimePeriodEnd :: !(Maybe DateTime) -- ^ "time_period_end" - Gets or sets the end time of the time period.
  , indexesIndexTimeseriesItemTimeOpen :: !(Maybe DateTime) -- ^ "time_open" - Gets or sets the time when the value opened.
  , indexesIndexTimeseriesItemTimeClose :: !(Maybe DateTime) -- ^ "time_close" - Gets or sets the time when the value closed.
  , indexesIndexTimeseriesItemValueOpen :: !(Maybe Double) -- ^ "value_open" - Gets or sets the opening value.
  , indexesIndexTimeseriesItemValueHigh :: !(Maybe Double) -- ^ "value_high" - Gets or sets the highest value during the time period.
  , indexesIndexTimeseriesItemValueLow :: !(Maybe Double) -- ^ "value_low" - Gets or sets the lowest value during the time period.
  , indexesIndexTimeseriesItemValueClose :: !(Maybe Double) -- ^ "value_close" - Gets or sets the closing value.
  , indexesIndexTimeseriesItemValueCount :: !(Maybe Integer) -- ^ "value_count" - Gets or sets the number of values during the time period.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexTimeseriesItem
instance A.FromJSON IndexesIndexTimeseriesItem where
  parseJSON = A.withObject "IndexesIndexTimeseriesItem" $ \o ->
    IndexesIndexTimeseriesItem
      <$> (o .:? "time_period_start")
      <*> (o .:? "time_period_end")
      <*> (o .:? "time_open")
      <*> (o .:? "time_close")
      <*> (o .:? "value_open")
      <*> (o .:? "value_high")
      <*> (o .:? "value_low")
      <*> (o .:? "value_close")
      <*> (o .:? "value_count")

-- | ToJSON IndexesIndexTimeseriesItem
instance A.ToJSON IndexesIndexTimeseriesItem where
  toJSON IndexesIndexTimeseriesItem {..} =
   _omitNulls
      [ "time_period_start" .= indexesIndexTimeseriesItemTimePeriodStart
      , "time_period_end" .= indexesIndexTimeseriesItemTimePeriodEnd
      , "time_open" .= indexesIndexTimeseriesItemTimeOpen
      , "time_close" .= indexesIndexTimeseriesItemTimeClose
      , "value_open" .= indexesIndexTimeseriesItemValueOpen
      , "value_high" .= indexesIndexTimeseriesItemValueHigh
      , "value_low" .= indexesIndexTimeseriesItemValueLow
      , "value_close" .= indexesIndexTimeseriesItemValueClose
      , "value_count" .= indexesIndexTimeseriesItemValueCount
      ]


-- | Construct a value of type 'IndexesIndexTimeseriesItem' (by applying it's required fields, if any)
mkIndexesIndexTimeseriesItem
  :: IndexesIndexTimeseriesItem
mkIndexesIndexTimeseriesItem =
  IndexesIndexTimeseriesItem
  { indexesIndexTimeseriesItemTimePeriodStart = Nothing
  , indexesIndexTimeseriesItemTimePeriodEnd = Nothing
  , indexesIndexTimeseriesItemTimeOpen = Nothing
  , indexesIndexTimeseriesItemTimeClose = Nothing
  , indexesIndexTimeseriesItemValueOpen = Nothing
  , indexesIndexTimeseriesItemValueHigh = Nothing
  , indexesIndexTimeseriesItemValueLow = Nothing
  , indexesIndexTimeseriesItemValueClose = Nothing
  , indexesIndexTimeseriesItemValueCount = Nothing
  }

-- ** IndexesIndexValue
-- | IndexesIndexValue
data IndexesIndexValue = IndexesIndexValue
  { indexesIndexValueTimestamp :: !(Maybe DateTime) -- ^ "timestamp"
  , indexesIndexValueValue :: !(Maybe Double) -- ^ "value"
  , indexesIndexValueComposition :: !(Maybe [IndexesIndexValueComponent]) -- ^ "composition"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexValue
instance A.FromJSON IndexesIndexValue where
  parseJSON = A.withObject "IndexesIndexValue" $ \o ->
    IndexesIndexValue
      <$> (o .:? "timestamp")
      <*> (o .:? "value")
      <*> (o .:? "composition")

-- | ToJSON IndexesIndexValue
instance A.ToJSON IndexesIndexValue where
  toJSON IndexesIndexValue {..} =
   _omitNulls
      [ "timestamp" .= indexesIndexValueTimestamp
      , "value" .= indexesIndexValueValue
      , "composition" .= indexesIndexValueComposition
      ]


-- | Construct a value of type 'IndexesIndexValue' (by applying it's required fields, if any)
mkIndexesIndexValue
  :: IndexesIndexValue
mkIndexesIndexValue =
  IndexesIndexValue
  { indexesIndexValueTimestamp = Nothing
  , indexesIndexValueValue = Nothing
  , indexesIndexValueComposition = Nothing
  }

-- ** IndexesIndexValueComponent
-- | IndexesIndexValueComponent
data IndexesIndexValueComponent = IndexesIndexValueComponent
  { indexesIndexValueComponentComponentId :: !(Maybe Text) -- ^ "component_id"
  , indexesIndexValueComponentComponentValue :: !(Maybe Double) -- ^ "component_value"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON IndexesIndexValueComponent
instance A.FromJSON IndexesIndexValueComponent where
  parseJSON = A.withObject "IndexesIndexValueComponent" $ \o ->
    IndexesIndexValueComponent
      <$> (o .:? "component_id")
      <*> (o .:? "component_value")

-- | ToJSON IndexesIndexValueComponent
instance A.ToJSON IndexesIndexValueComponent where
  toJSON IndexesIndexValueComponent {..} =
   _omitNulls
      [ "component_id" .= indexesIndexValueComponentComponentId
      , "component_value" .= indexesIndexValueComponentComponentValue
      ]


-- | Construct a value of type 'IndexesIndexValueComponent' (by applying it's required fields, if any)
mkIndexesIndexValueComponent
  :: IndexesIndexValueComponent
mkIndexesIndexValueComponent =
  IndexesIndexValueComponent
  { indexesIndexValueComponentComponentId = Nothing
  , indexesIndexValueComponentComponentValue = Nothing
  }

-- ** MetadataExchange
-- | MetadataExchange
-- Represents an exchange.
data MetadataExchange = MetadataExchange
  { metadataExchangeExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Gets or sets the exchange ID.
  , metadataExchangeWebsite :: !(Maybe Text) -- ^ "website" - Gets or sets the website URL of the exchange.
  , metadataExchangeName :: !(Maybe Text) -- ^ "name" - Gets or sets the name of the exchange.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetadataExchange
instance A.FromJSON MetadataExchange where
  parseJSON = A.withObject "MetadataExchange" $ \o ->
    MetadataExchange
      <$> (o .:? "exchange_id")
      <*> (o .:? "website")
      <*> (o .:? "name")

-- | ToJSON MetadataExchange
instance A.ToJSON MetadataExchange where
  toJSON MetadataExchange {..} =
   _omitNulls
      [ "exchange_id" .= metadataExchangeExchangeId
      , "website" .= metadataExchangeWebsite
      , "name" .= metadataExchangeName
      ]


-- | Construct a value of type 'MetadataExchange' (by applying it's required fields, if any)
mkMetadataExchange
  :: MetadataExchange
mkMetadataExchange =
  MetadataExchange
  { metadataExchangeExchangeId = Nothing
  , metadataExchangeWebsite = Nothing
  , metadataExchangeName = Nothing
  }

-- ** MetadataTimeseriesPeriod
-- | MetadataTimeseriesPeriod
-- Represents a timeseries period used in exchange rate data.
data MetadataTimeseriesPeriod = MetadataTimeseriesPeriod
  { metadataTimeseriesPeriodPeriodId :: !(Maybe Text) -- ^ "period_id" - Gets or sets the period ID.
  , metadataTimeseriesPeriodLengthSeconds :: !(Maybe Int) -- ^ "length_seconds" - Gets or sets the length of the period in seconds.
  , metadataTimeseriesPeriodLengthMonths :: !(Maybe Int) -- ^ "length_months" - Gets or sets the length of the period in months.
  , metadataTimeseriesPeriodUnitCount :: !(Maybe Int) -- ^ "unit_count" - Gets or sets the unit count.
  , metadataTimeseriesPeriodUnitName :: !(Maybe Text) -- ^ "unit_name" - Gets or sets the unit name.
  , metadataTimeseriesPeriodDisplayName :: !(Maybe Text) -- ^ "display_name" - Gets or sets the display name of the timeseries period.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MetadataTimeseriesPeriod
instance A.FromJSON MetadataTimeseriesPeriod where
  parseJSON = A.withObject "MetadataTimeseriesPeriod" $ \o ->
    MetadataTimeseriesPeriod
      <$> (o .:? "period_id")
      <*> (o .:? "length_seconds")
      <*> (o .:? "length_months")
      <*> (o .:? "unit_count")
      <*> (o .:? "unit_name")
      <*> (o .:? "display_name")

-- | ToJSON MetadataTimeseriesPeriod
instance A.ToJSON MetadataTimeseriesPeriod where
  toJSON MetadataTimeseriesPeriod {..} =
   _omitNulls
      [ "period_id" .= metadataTimeseriesPeriodPeriodId
      , "length_seconds" .= metadataTimeseriesPeriodLengthSeconds
      , "length_months" .= metadataTimeseriesPeriodLengthMonths
      , "unit_count" .= metadataTimeseriesPeriodUnitCount
      , "unit_name" .= metadataTimeseriesPeriodUnitName
      , "display_name" .= metadataTimeseriesPeriodDisplayName
      ]


-- | Construct a value of type 'MetadataTimeseriesPeriod' (by applying it's required fields, if any)
mkMetadataTimeseriesPeriod
  :: MetadataTimeseriesPeriod
mkMetadataTimeseriesPeriod =
  MetadataTimeseriesPeriod
  { metadataTimeseriesPeriodPeriodId = Nothing
  , metadataTimeseriesPeriodLengthSeconds = Nothing
  , metadataTimeseriesPeriodLengthMonths = Nothing
  , metadataTimeseriesPeriodUnitCount = Nothing
  , metadataTimeseriesPeriodUnitName = Nothing
  , metadataTimeseriesPeriodDisplayName = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-CoinAPI-Key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


