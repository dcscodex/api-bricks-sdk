{-
   CoinAPI Market Data REST API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.4
   CoinAPI Market Data REST API API version: v1
   Contact: support@apibricks.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : CoinAPIMarketDataREST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module CoinAPIMarketDataREST.Model where

import CoinAPIMarketDataREST.Core
import CoinAPIMarketDataREST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AssetId
newtype AssetId = AssetId { unAssetId :: Text } deriving (P.Eq, P.Show)

-- ** AssetIdBase
newtype AssetIdBase = AssetIdBase { unAssetIdBase :: Text } deriving (P.Eq, P.Show)

-- ** AssetIdExternal
newtype AssetIdExternal = AssetIdExternal { unAssetIdExternal :: Text } deriving (P.Eq, P.Show)

-- ** AssetIdQuote
newtype AssetIdQuote = AssetIdQuote { unAssetIdQuote :: Text } deriving (P.Eq, P.Show)

-- ** ChainId
newtype ChainId = ChainId { unChainId :: Text } deriving (P.Eq, P.Show)

-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- ** FilterAssetId
newtype FilterAssetId = FilterAssetId { unFilterAssetId :: Text } deriving (P.Eq, P.Show)

-- ** FilterChainId
newtype FilterChainId = FilterChainId { unFilterChainId :: Text } deriving (P.Eq, P.Show)

-- ** FilterExchangeId
newtype FilterExchangeId = FilterExchangeId { unFilterExchangeId :: Text } deriving (P.Eq, P.Show)

-- ** FilterSymbolId
newtype FilterSymbolId = FilterSymbolId { unFilterSymbolId :: Text } deriving (P.Eq, P.Show)

-- ** IncludeEmptyItems
newtype IncludeEmptyItems = IncludeEmptyItems { unIncludeEmptyItems :: Bool } deriving (P.Eq, P.Show)

-- ** IncludeId
newtype IncludeId = IncludeId { unIncludeId :: Bool } deriving (P.Eq, P.Show)

-- ** Invert
newtype Invert = Invert { unInvert :: Bool } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** LimitLevels
newtype LimitLevels = LimitLevels { unLimitLevels :: Int } deriving (P.Eq, P.Show)

-- ** MetricId
newtype MetricId = MetricId { unMetricId :: Text } deriving (P.Eq, P.Show)

-- ** NetworkId
newtype NetworkId = NetworkId { unNetworkId :: Text } deriving (P.Eq, P.Show)

-- ** ParamDate
newtype ParamDate = ParamDate { unParamDate :: Text } deriving (P.Eq, P.Show)

-- ** PeriodId
newtype PeriodId = PeriodId { unPeriodId :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: Int } deriving (P.Eq, P.Show)

-- ** SymbolId
newtype SymbolId = SymbolId { unSymbolId :: Text } deriving (P.Eq, P.Show)

-- ** Time
newtype Time = Time { unTime :: Text } deriving (P.Eq, P.Show)

-- ** TimeEnd
newtype TimeEnd = TimeEnd { unTimeEnd :: Text } deriving (P.Eq, P.Show)

-- ** TimeEndDateTime
newtype TimeEndDateTime = TimeEndDateTime { unTimeEndDateTime :: DateTime } deriving (P.Eq, P.Show)

-- ** TimeFormat
newtype TimeFormat = TimeFormat { unTimeFormat :: Text } deriving (P.Eq, P.Show)

-- ** TimeStart
newtype TimeStart = TimeStart { unTimeStart :: Text } deriving (P.Eq, P.Show)

-- ** TimeStartDateTime
newtype TimeStartDateTime = TimeStartDateTime { unTimeStartDateTime :: DateTime } deriving (P.Eq, P.Show)

-- * Models


-- ** ModelsExchangeTimeseriesItem
-- | ModelsExchangeTimeseriesItem
-- Represents a timeseries item with price and volume information.
data ModelsExchangeTimeseriesItem = ModelsExchangeTimeseriesItem
  { modelsExchangeTimeseriesItemTimePeriodStart :: !(Maybe DateTime) -- ^ "time_period_start" - The start time of the time period.
  , modelsExchangeTimeseriesItemTimePeriodEnd :: !(Maybe DateTime) -- ^ "time_period_end" - The end time of the time period.
  , modelsExchangeTimeseriesItemTimeOpen :: !(Maybe DateTime) -- ^ "time_open" - The time when the price opened.
  , modelsExchangeTimeseriesItemTimeClose :: !(Maybe DateTime) -- ^ "time_close" - The time when the price closed.
  , modelsExchangeTimeseriesItemPriceOpen :: !(Maybe Double) -- ^ "price_open" - The opening price.
  , modelsExchangeTimeseriesItemPriceHigh :: !(Maybe Double) -- ^ "price_high" - The highest price during the time period.
  , modelsExchangeTimeseriesItemPriceLow :: !(Maybe Double) -- ^ "price_low" - The lowest price during the time period.
  , modelsExchangeTimeseriesItemPriceClose :: !(Maybe Double) -- ^ "price_close" - The closing price.
  , modelsExchangeTimeseriesItemVolumeTraded :: !(Maybe Double) -- ^ "volume_traded" - The total volume traded during the time period.
  , modelsExchangeTimeseriesItemTradesCount :: !(Maybe Integer) -- ^ "trades_count" - The number of trades executed during the time period.
  , modelsExchangeTimeseriesItemSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange"
  , modelsExchangeTimeseriesItemSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModelsExchangeTimeseriesItem
instance A.FromJSON ModelsExchangeTimeseriesItem where
  parseJSON = A.withObject "ModelsExchangeTimeseriesItem" $ \o ->
    ModelsExchangeTimeseriesItem
      <$> (o .:? "time_period_start")
      <*> (o .:? "time_period_end")
      <*> (o .:? "time_open")
      <*> (o .:? "time_close")
      <*> (o .:? "price_open")
      <*> (o .:? "price_high")
      <*> (o .:? "price_low")
      <*> (o .:? "price_close")
      <*> (o .:? "volume_traded")
      <*> (o .:? "trades_count")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")

-- | ToJSON ModelsExchangeTimeseriesItem
instance A.ToJSON ModelsExchangeTimeseriesItem where
  toJSON ModelsExchangeTimeseriesItem {..} =
   _omitNulls
      [ "time_period_start" .= modelsExchangeTimeseriesItemTimePeriodStart
      , "time_period_end" .= modelsExchangeTimeseriesItemTimePeriodEnd
      , "time_open" .= modelsExchangeTimeseriesItemTimeOpen
      , "time_close" .= modelsExchangeTimeseriesItemTimeClose
      , "price_open" .= modelsExchangeTimeseriesItemPriceOpen
      , "price_high" .= modelsExchangeTimeseriesItemPriceHigh
      , "price_low" .= modelsExchangeTimeseriesItemPriceLow
      , "price_close" .= modelsExchangeTimeseriesItemPriceClose
      , "volume_traded" .= modelsExchangeTimeseriesItemVolumeTraded
      , "trades_count" .= modelsExchangeTimeseriesItemTradesCount
      , "symbol_id_exchange" .= modelsExchangeTimeseriesItemSymbolIdExchange
      , "symbol_id_coinapi" .= modelsExchangeTimeseriesItemSymbolIdCoinapi
      ]


-- | Construct a value of type 'ModelsExchangeTimeseriesItem' (by applying it's required fields, if any)
mkModelsExchangeTimeseriesItem
  :: ModelsExchangeTimeseriesItem
mkModelsExchangeTimeseriesItem =
  ModelsExchangeTimeseriesItem
  { modelsExchangeTimeseriesItemTimePeriodStart = Nothing
  , modelsExchangeTimeseriesItemTimePeriodEnd = Nothing
  , modelsExchangeTimeseriesItemTimeOpen = Nothing
  , modelsExchangeTimeseriesItemTimeClose = Nothing
  , modelsExchangeTimeseriesItemPriceOpen = Nothing
  , modelsExchangeTimeseriesItemPriceHigh = Nothing
  , modelsExchangeTimeseriesItemPriceLow = Nothing
  , modelsExchangeTimeseriesItemPriceClose = Nothing
  , modelsExchangeTimeseriesItemVolumeTraded = Nothing
  , modelsExchangeTimeseriesItemTradesCount = Nothing
  , modelsExchangeTimeseriesItemSymbolIdExchange = Nothing
  , modelsExchangeTimeseriesItemSymbolIdCoinapi = Nothing
  }

-- ** OptionsOptionExchangeGroup
-- | OptionsOptionExchangeGroup
-- Represents an option exchange group data model.
data OptionsOptionExchangeGroup = OptionsOptionExchangeGroup
  { optionsOptionExchangeGroupAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - The base asset identifier.
  , optionsOptionExchangeGroupAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - The quote asset identifier.
  , optionsOptionExchangeGroupUnderlyingPrice :: !(Maybe Double) -- ^ "underlying_price" - The underlying price of the option.
  , optionsOptionExchangeGroupTimeExpiration :: !(Maybe DateTime) -- ^ "time_expiration" - The expiration time of the option.
  , optionsOptionExchangeGroupStrikes :: !(Maybe [OptionsStrike]) -- ^ "strikes" - The list of strikes available.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OptionsOptionExchangeGroup
instance A.FromJSON OptionsOptionExchangeGroup where
  parseJSON = A.withObject "OptionsOptionExchangeGroup" $ \o ->
    OptionsOptionExchangeGroup
      <$> (o .:? "asset_id_base")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "underlying_price")
      <*> (o .:? "time_expiration")
      <*> (o .:? "strikes")

-- | ToJSON OptionsOptionExchangeGroup
instance A.ToJSON OptionsOptionExchangeGroup where
  toJSON OptionsOptionExchangeGroup {..} =
   _omitNulls
      [ "asset_id_base" .= optionsOptionExchangeGroupAssetIdBase
      , "asset_id_quote" .= optionsOptionExchangeGroupAssetIdQuote
      , "underlying_price" .= optionsOptionExchangeGroupUnderlyingPrice
      , "time_expiration" .= optionsOptionExchangeGroupTimeExpiration
      , "strikes" .= optionsOptionExchangeGroupStrikes
      ]


-- | Construct a value of type 'OptionsOptionExchangeGroup' (by applying it's required fields, if any)
mkOptionsOptionExchangeGroup
  :: OptionsOptionExchangeGroup
mkOptionsOptionExchangeGroup =
  OptionsOptionExchangeGroup
  { optionsOptionExchangeGroupAssetIdBase = Nothing
  , optionsOptionExchangeGroupAssetIdQuote = Nothing
  , optionsOptionExchangeGroupUnderlyingPrice = Nothing
  , optionsOptionExchangeGroupTimeExpiration = Nothing
  , optionsOptionExchangeGroupStrikes = Nothing
  }

-- ** OptionsStrike
-- | OptionsStrike
-- Represents a strike within the option exchange group.
data OptionsStrike = OptionsStrike
  { optionsStrikeStrikePrice :: !(Maybe Double) -- ^ "strike_price" - The strike price.
  , optionsStrikeCall :: !(Maybe V1QuoteTrade) -- ^ "call"
  , optionsStrikePut :: !(Maybe V1QuoteTrade) -- ^ "put"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OptionsStrike
instance A.FromJSON OptionsStrike where
  parseJSON = A.withObject "OptionsStrike" $ \o ->
    OptionsStrike
      <$> (o .:? "strike_price")
      <*> (o .:? "call")
      <*> (o .:? "put")

-- | ToJSON OptionsStrike
instance A.ToJSON OptionsStrike where
  toJSON OptionsStrike {..} =
   _omitNulls
      [ "strike_price" .= optionsStrikeStrikePrice
      , "call" .= optionsStrikeCall
      , "put" .= optionsStrikePut
      ]


-- | Construct a value of type 'OptionsStrike' (by applying it's required fields, if any)
mkOptionsStrike
  :: OptionsStrike
mkOptionsStrike =
  OptionsStrike
  { optionsStrikeStrikePrice = Nothing
  , optionsStrikeCall = Nothing
  , optionsStrikePut = Nothing
  }

-- ** V1Asset
-- | V1Asset
-- Represents an asset.
data V1Asset = V1Asset
  { v1AssetAssetId :: !(Maybe Text) -- ^ "asset_id" - Gets or sets the asset ID.
  , v1AssetName :: !(Maybe Text) -- ^ "name" - Gets or sets the name of the asset.
  , v1AssetTypeIsCrypto :: !(Maybe Int) -- ^ "type_is_crypto" - Gets or sets a value indicating whether the asset is a cryptocurrency.
  , v1AssetDataQuoteStart :: !(Maybe DateTime) -- ^ "data_quote_start" - Gets or sets the start date of quote data.
  , v1AssetDataQuoteEnd :: !(Maybe DateTime) -- ^ "data_quote_end" - Gets or sets the end date of quote data.
  , v1AssetDataOrderbookStart :: !(Maybe DateTime) -- ^ "data_orderbook_start" - Gets or sets the start date of order book data.
  , v1AssetDataOrderbookEnd :: !(Maybe DateTime) -- ^ "data_orderbook_end" - Gets or sets the end date of order book data.
  , v1AssetDataTradeStart :: !(Maybe DateTime) -- ^ "data_trade_start" - Gets or sets the start date of trade data.
  , v1AssetDataTradeEnd :: !(Maybe DateTime) -- ^ "data_trade_end" - Gets or sets the end date of trade data.
  , v1AssetDataSymbolsCount :: !(Maybe Integer) -- ^ "data_symbols_count" - Gets or sets the number of symbols.
  , v1AssetVolume1hrsUsd :: !(Maybe Double) -- ^ "volume_1hrs_usd" - Gets or sets the USD volume in the last 1 hour.
  , v1AssetVolume1dayUsd :: !(Maybe Double) -- ^ "volume_1day_usd" - Gets or sets the USD volume in the last 1 day.
  , v1AssetVolume1mthUsd :: !(Maybe Double) -- ^ "volume_1mth_usd" - Gets or sets the USD volume in the last 1 month.
  , v1AssetPriceUsd :: !(Maybe Double) -- ^ "price_usd" - Gets or sets the USD price of the asset.
  , v1AssetIdIcon :: !(Maybe Text) -- ^ "id_icon" - Gets or sets the ID of the icon for the asset.
  , v1AssetSupplyCurrent :: !(Maybe Double) -- ^ "supply_current" - Gets or sets the current supply of the asset.
  , v1AssetSupplyTotal :: !(Maybe Double) -- ^ "supply_total" - Gets or sets the total supply of the asset.
  , v1AssetSupplyMax :: !(Maybe Double) -- ^ "supply_max" - Gets or sets the maximum supply of the asset.
  , v1AssetChainAddresses :: !(Maybe [V1ChainNetworkAddress]) -- ^ "chain_addresses" - 
  , v1AssetDataStart :: !(Maybe Text) -- ^ /ReadOnly/ "data_start"
  , v1AssetDataEnd :: !(Maybe Text) -- ^ /ReadOnly/ "data_end"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Asset
instance A.FromJSON V1Asset where
  parseJSON = A.withObject "V1Asset" $ \o ->
    V1Asset
      <$> (o .:? "asset_id")
      <*> (o .:? "name")
      <*> (o .:? "type_is_crypto")
      <*> (o .:? "data_quote_start")
      <*> (o .:? "data_quote_end")
      <*> (o .:? "data_orderbook_start")
      <*> (o .:? "data_orderbook_end")
      <*> (o .:? "data_trade_start")
      <*> (o .:? "data_trade_end")
      <*> (o .:? "data_symbols_count")
      <*> (o .:? "volume_1hrs_usd")
      <*> (o .:? "volume_1day_usd")
      <*> (o .:? "volume_1mth_usd")
      <*> (o .:? "price_usd")
      <*> (o .:? "id_icon")
      <*> (o .:? "supply_current")
      <*> (o .:? "supply_total")
      <*> (o .:? "supply_max")
      <*> (o .:? "chain_addresses")
      <*> (o .:? "data_start")
      <*> (o .:? "data_end")

-- | ToJSON V1Asset
instance A.ToJSON V1Asset where
  toJSON V1Asset {..} =
   _omitNulls
      [ "asset_id" .= v1AssetAssetId
      , "name" .= v1AssetName
      , "type_is_crypto" .= v1AssetTypeIsCrypto
      , "data_quote_start" .= v1AssetDataQuoteStart
      , "data_quote_end" .= v1AssetDataQuoteEnd
      , "data_orderbook_start" .= v1AssetDataOrderbookStart
      , "data_orderbook_end" .= v1AssetDataOrderbookEnd
      , "data_trade_start" .= v1AssetDataTradeStart
      , "data_trade_end" .= v1AssetDataTradeEnd
      , "data_symbols_count" .= v1AssetDataSymbolsCount
      , "volume_1hrs_usd" .= v1AssetVolume1hrsUsd
      , "volume_1day_usd" .= v1AssetVolume1dayUsd
      , "volume_1mth_usd" .= v1AssetVolume1mthUsd
      , "price_usd" .= v1AssetPriceUsd
      , "id_icon" .= v1AssetIdIcon
      , "supply_current" .= v1AssetSupplyCurrent
      , "supply_total" .= v1AssetSupplyTotal
      , "supply_max" .= v1AssetSupplyMax
      , "chain_addresses" .= v1AssetChainAddresses
      , "data_start" .= v1AssetDataStart
      , "data_end" .= v1AssetDataEnd
      ]


-- | Construct a value of type 'V1Asset' (by applying it's required fields, if any)
mkV1Asset
  :: V1Asset
mkV1Asset =
  V1Asset
  { v1AssetAssetId = Nothing
  , v1AssetName = Nothing
  , v1AssetTypeIsCrypto = Nothing
  , v1AssetDataQuoteStart = Nothing
  , v1AssetDataQuoteEnd = Nothing
  , v1AssetDataOrderbookStart = Nothing
  , v1AssetDataOrderbookEnd = Nothing
  , v1AssetDataTradeStart = Nothing
  , v1AssetDataTradeEnd = Nothing
  , v1AssetDataSymbolsCount = Nothing
  , v1AssetVolume1hrsUsd = Nothing
  , v1AssetVolume1dayUsd = Nothing
  , v1AssetVolume1mthUsd = Nothing
  , v1AssetPriceUsd = Nothing
  , v1AssetIdIcon = Nothing
  , v1AssetSupplyCurrent = Nothing
  , v1AssetSupplyTotal = Nothing
  , v1AssetSupplyMax = Nothing
  , v1AssetChainAddresses = Nothing
  , v1AssetDataStart = Nothing
  , v1AssetDataEnd = Nothing
  }

-- ** V1Chain
-- | V1Chain
-- Represents a blockchain chain.
data V1Chain = V1Chain
  { v1ChainChainId :: !(Maybe Text) -- ^ "chain_id" - Gets or sets the chain identifier.
  , v1ChainName :: !(Maybe Text) -- ^ "name" - Gets or sets the name of the chain.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Chain
instance A.FromJSON V1Chain where
  parseJSON = A.withObject "V1Chain" $ \o ->
    V1Chain
      <$> (o .:? "chain_id")
      <*> (o .:? "name")

-- | ToJSON V1Chain
instance A.ToJSON V1Chain where
  toJSON V1Chain {..} =
   _omitNulls
      [ "chain_id" .= v1ChainChainId
      , "name" .= v1ChainName
      ]


-- | Construct a value of type 'V1Chain' (by applying it's required fields, if any)
mkV1Chain
  :: V1Chain
mkV1Chain =
  V1Chain
  { v1ChainChainId = Nothing
  , v1ChainName = Nothing
  }

-- ** V1ChainNetworkAddress
-- | V1ChainNetworkAddress
-- Contains information about assets' chain network addresses
data V1ChainNetworkAddress = V1ChainNetworkAddress
  { v1ChainNetworkAddressChainId :: !(Maybe Text) -- ^ "chain_id" - Gets or sets chain id
  , v1ChainNetworkAddressNetworkId :: !(Maybe Text) -- ^ "network_id" - Gets or sets network id
  , v1ChainNetworkAddressAddress :: !(Maybe Text) -- ^ "address" - Gets or sets chain address
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ChainNetworkAddress
instance A.FromJSON V1ChainNetworkAddress where
  parseJSON = A.withObject "V1ChainNetworkAddress" $ \o ->
    V1ChainNetworkAddress
      <$> (o .:? "chain_id")
      <*> (o .:? "network_id")
      <*> (o .:? "address")

-- | ToJSON V1ChainNetworkAddress
instance A.ToJSON V1ChainNetworkAddress where
  toJSON V1ChainNetworkAddress {..} =
   _omitNulls
      [ "chain_id" .= v1ChainNetworkAddressChainId
      , "network_id" .= v1ChainNetworkAddressNetworkId
      , "address" .= v1ChainNetworkAddressAddress
      ]


-- | Construct a value of type 'V1ChainNetworkAddress' (by applying it's required fields, if any)
mkV1ChainNetworkAddress
  :: V1ChainNetworkAddress
mkV1ChainNetworkAddress =
  V1ChainNetworkAddress
  { v1ChainNetworkAddressChainId = Nothing
  , v1ChainNetworkAddressNetworkId = Nothing
  , v1ChainNetworkAddressAddress = Nothing
  }

-- ** V1Exchange
-- | V1Exchange
-- Represents an exchange.
data V1Exchange = V1Exchange
  { v1ExchangeExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Gets or sets the exchange ID.
  , v1ExchangeWebsite :: !(Maybe Text) -- ^ "website" - Gets or sets the website URL of the exchange.
  , v1ExchangeName :: !(Maybe Text) -- ^ "name" - Gets or sets the name of the exchange.
  , v1ExchangeDataStart :: !(Maybe Text) -- ^ /ReadOnly/ "data_start"
  , v1ExchangeDataEnd :: !(Maybe Text) -- ^ /ReadOnly/ "data_end"
  , v1ExchangeDataQuoteStart :: !(Maybe DateTime) -- ^ "data_quote_start" - Gets or sets the start date of quote data.
  , v1ExchangeDataQuoteEnd :: !(Maybe DateTime) -- ^ "data_quote_end" - Gets or sets the end date of quote data.
  , v1ExchangeDataOrderbookStart :: !(Maybe DateTime) -- ^ "data_orderbook_start" - Gets or sets the start date of order book data.
  , v1ExchangeDataOrderbookEnd :: !(Maybe DateTime) -- ^ "data_orderbook_end" - Gets or sets the end date of order book data.
  , v1ExchangeDataTradeStart :: !(Maybe DateTime) -- ^ "data_trade_start" - Gets or sets the start date of trade data.
  , v1ExchangeDataTradeEnd :: !(Maybe DateTime) -- ^ "data_trade_end" - Gets or sets the end date of trade data.
  , v1ExchangeDataTradeCount :: !(Maybe Integer) -- ^ "data_trade_count" - Gets or sets the number of trades.
  , v1ExchangeDataSymbolsCount :: !(Maybe Integer) -- ^ "data_symbols_count" - Gets or sets the number of symbols.
  , v1ExchangeVolume1hrsUsd :: !(Maybe Double) -- ^ "volume_1hrs_usd" - Gets or sets the USD volume in the last 1 hour.
  , v1ExchangeVolume1dayUsd :: !(Maybe Double) -- ^ "volume_1day_usd" - Gets or sets the USD volume in the last 1 day.
  , v1ExchangeVolume1mthUsd :: !(Maybe Double) -- ^ "volume_1mth_usd" - Gets or sets the USD volume in the last 1 month.
  , v1ExchangeMetricId :: !(Maybe [Text]) -- ^ "metric_id" - Gets or sets the list of metric IDs.
  , v1ExchangeIcons :: !(Maybe [V1Icon]) -- ^ /ReadOnly/ "icons" - Gets or sets the list of icons for the exchange.
  , v1ExchangeRank :: !(Maybe Double) -- ^ "rank" - Rank of the exchange.
  , v1ExchangeIntegrationStatus :: !(Maybe Text) -- ^ "integration_status" - Status of the integration
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Exchange
instance A.FromJSON V1Exchange where
  parseJSON = A.withObject "V1Exchange" $ \o ->
    V1Exchange
      <$> (o .:? "exchange_id")
      <*> (o .:? "website")
      <*> (o .:? "name")
      <*> (o .:? "data_start")
      <*> (o .:? "data_end")
      <*> (o .:? "data_quote_start")
      <*> (o .:? "data_quote_end")
      <*> (o .:? "data_orderbook_start")
      <*> (o .:? "data_orderbook_end")
      <*> (o .:? "data_trade_start")
      <*> (o .:? "data_trade_end")
      <*> (o .:? "data_trade_count")
      <*> (o .:? "data_symbols_count")
      <*> (o .:? "volume_1hrs_usd")
      <*> (o .:? "volume_1day_usd")
      <*> (o .:? "volume_1mth_usd")
      <*> (o .:? "metric_id")
      <*> (o .:? "icons")
      <*> (o .:? "rank")
      <*> (o .:? "integration_status")

-- | ToJSON V1Exchange
instance A.ToJSON V1Exchange where
  toJSON V1Exchange {..} =
   _omitNulls
      [ "exchange_id" .= v1ExchangeExchangeId
      , "website" .= v1ExchangeWebsite
      , "name" .= v1ExchangeName
      , "data_start" .= v1ExchangeDataStart
      , "data_end" .= v1ExchangeDataEnd
      , "data_quote_start" .= v1ExchangeDataQuoteStart
      , "data_quote_end" .= v1ExchangeDataQuoteEnd
      , "data_orderbook_start" .= v1ExchangeDataOrderbookStart
      , "data_orderbook_end" .= v1ExchangeDataOrderbookEnd
      , "data_trade_start" .= v1ExchangeDataTradeStart
      , "data_trade_end" .= v1ExchangeDataTradeEnd
      , "data_trade_count" .= v1ExchangeDataTradeCount
      , "data_symbols_count" .= v1ExchangeDataSymbolsCount
      , "volume_1hrs_usd" .= v1ExchangeVolume1hrsUsd
      , "volume_1day_usd" .= v1ExchangeVolume1dayUsd
      , "volume_1mth_usd" .= v1ExchangeVolume1mthUsd
      , "metric_id" .= v1ExchangeMetricId
      , "icons" .= v1ExchangeIcons
      , "rank" .= v1ExchangeRank
      , "integration_status" .= v1ExchangeIntegrationStatus
      ]


-- | Construct a value of type 'V1Exchange' (by applying it's required fields, if any)
mkV1Exchange
  :: V1Exchange
mkV1Exchange =
  V1Exchange
  { v1ExchangeExchangeId = Nothing
  , v1ExchangeWebsite = Nothing
  , v1ExchangeName = Nothing
  , v1ExchangeDataStart = Nothing
  , v1ExchangeDataEnd = Nothing
  , v1ExchangeDataQuoteStart = Nothing
  , v1ExchangeDataQuoteEnd = Nothing
  , v1ExchangeDataOrderbookStart = Nothing
  , v1ExchangeDataOrderbookEnd = Nothing
  , v1ExchangeDataTradeStart = Nothing
  , v1ExchangeDataTradeEnd = Nothing
  , v1ExchangeDataTradeCount = Nothing
  , v1ExchangeDataSymbolsCount = Nothing
  , v1ExchangeVolume1hrsUsd = Nothing
  , v1ExchangeVolume1dayUsd = Nothing
  , v1ExchangeVolume1mthUsd = Nothing
  , v1ExchangeMetricId = Nothing
  , v1ExchangeIcons = Nothing
  , v1ExchangeRank = Nothing
  , v1ExchangeIntegrationStatus = Nothing
  }

-- ** V1ExchangeRate
-- | V1ExchangeRate
-- Represents an exchange rate.
data V1ExchangeRate = V1ExchangeRate
  { v1ExchangeRateTime :: !(Maybe DateTime) -- ^ "time" - Gets or sets the time of the exchange rate.
  , v1ExchangeRateAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - Gets or sets the base asset ID of the exchange rate.
  , v1ExchangeRateAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - Gets or sets the quote asset ID of the exchange rate.
  , v1ExchangeRateRate :: !(Maybe Double) -- ^ "rate" - Gets or sets the exchange rate value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRate
instance A.FromJSON V1ExchangeRate where
  parseJSON = A.withObject "V1ExchangeRate" $ \o ->
    V1ExchangeRate
      <$> (o .:? "time")
      <*> (o .:? "asset_id_base")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "rate")

-- | ToJSON V1ExchangeRate
instance A.ToJSON V1ExchangeRate where
  toJSON V1ExchangeRate {..} =
   _omitNulls
      [ "time" .= v1ExchangeRateTime
      , "asset_id_base" .= v1ExchangeRateAssetIdBase
      , "asset_id_quote" .= v1ExchangeRateAssetIdQuote
      , "rate" .= v1ExchangeRateRate
      ]


-- | Construct a value of type 'V1ExchangeRate' (by applying it's required fields, if any)
mkV1ExchangeRate
  :: V1ExchangeRate
mkV1ExchangeRate =
  V1ExchangeRate
  { v1ExchangeRateTime = Nothing
  , v1ExchangeRateAssetIdBase = Nothing
  , v1ExchangeRateAssetIdQuote = Nothing
  , v1ExchangeRateRate = Nothing
  }

-- ** V1ExchangeRates
-- | V1ExchangeRates
-- Represents exchange rates for a specific base asset.
data V1ExchangeRates = V1ExchangeRates
  { v1ExchangeRatesAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - Gets or sets the base asset ID.
  , v1ExchangeRatesRates :: !(Maybe [V1ExchangeRatesRate]) -- ^ "rates" - Gets or sets the list of exchange rates.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRates
instance A.FromJSON V1ExchangeRates where
  parseJSON = A.withObject "V1ExchangeRates" $ \o ->
    V1ExchangeRates
      <$> (o .:? "asset_id_base")
      <*> (o .:? "rates")

-- | ToJSON V1ExchangeRates
instance A.ToJSON V1ExchangeRates where
  toJSON V1ExchangeRates {..} =
   _omitNulls
      [ "asset_id_base" .= v1ExchangeRatesAssetIdBase
      , "rates" .= v1ExchangeRatesRates
      ]


-- | Construct a value of type 'V1ExchangeRates' (by applying it's required fields, if any)
mkV1ExchangeRates
  :: V1ExchangeRates
mkV1ExchangeRates =
  V1ExchangeRates
  { v1ExchangeRatesAssetIdBase = Nothing
  , v1ExchangeRatesRates = Nothing
  }

-- ** V1ExchangeRatesRate
-- | V1ExchangeRatesRate
-- Represents an exchange rate within a collection of exchange rates.
data V1ExchangeRatesRate = V1ExchangeRatesRate
  { v1ExchangeRatesRateTime :: !(Maybe DateTime) -- ^ "time" - Gets or sets the time of the exchange rate.
  , v1ExchangeRatesRateAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - Gets or sets the quote asset ID of the exchange rate.
  , v1ExchangeRatesRateRate :: !(Maybe Double) -- ^ "rate" - Gets or sets the exchange rate value.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRatesRate
instance A.FromJSON V1ExchangeRatesRate where
  parseJSON = A.withObject "V1ExchangeRatesRate" $ \o ->
    V1ExchangeRatesRate
      <$> (o .:? "time")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "rate")

-- | ToJSON V1ExchangeRatesRate
instance A.ToJSON V1ExchangeRatesRate where
  toJSON V1ExchangeRatesRate {..} =
   _omitNulls
      [ "time" .= v1ExchangeRatesRateTime
      , "asset_id_quote" .= v1ExchangeRatesRateAssetIdQuote
      , "rate" .= v1ExchangeRatesRateRate
      ]


-- | Construct a value of type 'V1ExchangeRatesRate' (by applying it's required fields, if any)
mkV1ExchangeRatesRate
  :: V1ExchangeRatesRate
mkV1ExchangeRatesRate =
  V1ExchangeRatesRate
  { v1ExchangeRatesRateTime = Nothing
  , v1ExchangeRatesRateAssetIdQuote = Nothing
  , v1ExchangeRatesRateRate = Nothing
  }

-- ** V1ExchangeRatesTimeseriesItem
-- | V1ExchangeRatesTimeseriesItem
-- Represents an item in the exchange rate timeseries.
data V1ExchangeRatesTimeseriesItem = V1ExchangeRatesTimeseriesItem
  { v1ExchangeRatesTimeseriesItemTimePeriodStart :: !(Maybe DateTime) -- ^ "time_period_start" - Gets or sets the start time of the period.
  , v1ExchangeRatesTimeseriesItemTimePeriodEnd :: !(Maybe DateTime) -- ^ "time_period_end" - Gets or sets the end time of the period.
  , v1ExchangeRatesTimeseriesItemTimeOpen :: !(Maybe DateTime) -- ^ "time_open" - Gets or sets the opening time of the period.
  , v1ExchangeRatesTimeseriesItemTimeClose :: !(Maybe DateTime) -- ^ "time_close" - Gets or sets the closing time of the period.
  , v1ExchangeRatesTimeseriesItemRateOpen :: !(Maybe Double) -- ^ "rate_open" - Gets or sets the opening rate for the period.
  , v1ExchangeRatesTimeseriesItemRateHigh :: !(Maybe Double) -- ^ "rate_high" - Gets or sets the highest rate for the period.
  , v1ExchangeRatesTimeseriesItemRateLow :: !(Maybe Double) -- ^ "rate_low" - Gets or sets the lowest rate for the period.
  , v1ExchangeRatesTimeseriesItemRateClose :: !(Maybe Double) -- ^ "rate_close" - Gets or sets the closing rate for the period.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ExchangeRatesTimeseriesItem
instance A.FromJSON V1ExchangeRatesTimeseriesItem where
  parseJSON = A.withObject "V1ExchangeRatesTimeseriesItem" $ \o ->
    V1ExchangeRatesTimeseriesItem
      <$> (o .:? "time_period_start")
      <*> (o .:? "time_period_end")
      <*> (o .:? "time_open")
      <*> (o .:? "time_close")
      <*> (o .:? "rate_open")
      <*> (o .:? "rate_high")
      <*> (o .:? "rate_low")
      <*> (o .:? "rate_close")

-- | ToJSON V1ExchangeRatesTimeseriesItem
instance A.ToJSON V1ExchangeRatesTimeseriesItem where
  toJSON V1ExchangeRatesTimeseriesItem {..} =
   _omitNulls
      [ "time_period_start" .= v1ExchangeRatesTimeseriesItemTimePeriodStart
      , "time_period_end" .= v1ExchangeRatesTimeseriesItemTimePeriodEnd
      , "time_open" .= v1ExchangeRatesTimeseriesItemTimeOpen
      , "time_close" .= v1ExchangeRatesTimeseriesItemTimeClose
      , "rate_open" .= v1ExchangeRatesTimeseriesItemRateOpen
      , "rate_high" .= v1ExchangeRatesTimeseriesItemRateHigh
      , "rate_low" .= v1ExchangeRatesTimeseriesItemRateLow
      , "rate_close" .= v1ExchangeRatesTimeseriesItemRateClose
      ]


-- | Construct a value of type 'V1ExchangeRatesTimeseriesItem' (by applying it's required fields, if any)
mkV1ExchangeRatesTimeseriesItem
  :: V1ExchangeRatesTimeseriesItem
mkV1ExchangeRatesTimeseriesItem =
  V1ExchangeRatesTimeseriesItem
  { v1ExchangeRatesTimeseriesItemTimePeriodStart = Nothing
  , v1ExchangeRatesTimeseriesItemTimePeriodEnd = Nothing
  , v1ExchangeRatesTimeseriesItemTimeOpen = Nothing
  , v1ExchangeRatesTimeseriesItemTimeClose = Nothing
  , v1ExchangeRatesTimeseriesItemRateOpen = Nothing
  , v1ExchangeRatesTimeseriesItemRateHigh = Nothing
  , v1ExchangeRatesTimeseriesItemRateLow = Nothing
  , v1ExchangeRatesTimeseriesItemRateClose = Nothing
  }

-- ** V1GeneralData
-- | V1GeneralData
-- Class representation of general metric data. This class is an XML type with name 'general_data' and inherits from the BaseCsvModel class.
data V1GeneralData = V1GeneralData
  { v1GeneralDataEntryTime :: !(Maybe DateTime) -- ^ "entry_time" - Gets or sets the entry time for the data point.
  , v1GeneralDataRecvTime :: !(Maybe DateTime) -- ^ "recv_time" - Gets or sets the received time for the data point.
  , v1GeneralDataExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Gets or sets the identifier for the exchange.
  , v1GeneralDataAssetId :: !(Maybe Text) -- ^ "asset_id" - Gets or sets the identifier for the asset.
  , v1GeneralDataSymbolId :: !(Maybe Text) -- ^ "symbol_id" - Gets or sets the identifier for the symbol.
  , v1GeneralDataMetricId :: !(Maybe Text) -- ^ "metric_id" - Gets or sets the identifier for the metric.
  , v1GeneralDataValueDecimal :: !(Maybe Double) -- ^ "value_decimal" - Gets or sets the decimal value for the metric.
  , v1GeneralDataValueText :: !(Maybe Text) -- ^ "value_text" - Gets or sets the textual representation of the value for the metric.
  , v1GeneralDataValueTime :: !(Maybe DateTime) -- ^ "value_time" - Gets or sets the timestamp value for the metric.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1GeneralData
instance A.FromJSON V1GeneralData where
  parseJSON = A.withObject "V1GeneralData" $ \o ->
    V1GeneralData
      <$> (o .:? "entry_time")
      <*> (o .:? "recv_time")
      <*> (o .:? "exchange_id")
      <*> (o .:? "asset_id")
      <*> (o .:? "symbol_id")
      <*> (o .:? "metric_id")
      <*> (o .:? "value_decimal")
      <*> (o .:? "value_text")
      <*> (o .:? "value_time")

-- | ToJSON V1GeneralData
instance A.ToJSON V1GeneralData where
  toJSON V1GeneralData {..} =
   _omitNulls
      [ "entry_time" .= v1GeneralDataEntryTime
      , "recv_time" .= v1GeneralDataRecvTime
      , "exchange_id" .= v1GeneralDataExchangeId
      , "asset_id" .= v1GeneralDataAssetId
      , "symbol_id" .= v1GeneralDataSymbolId
      , "metric_id" .= v1GeneralDataMetricId
      , "value_decimal" .= v1GeneralDataValueDecimal
      , "value_text" .= v1GeneralDataValueText
      , "value_time" .= v1GeneralDataValueTime
      ]


-- | Construct a value of type 'V1GeneralData' (by applying it's required fields, if any)
mkV1GeneralData
  :: V1GeneralData
mkV1GeneralData =
  V1GeneralData
  { v1GeneralDataEntryTime = Nothing
  , v1GeneralDataRecvTime = Nothing
  , v1GeneralDataExchangeId = Nothing
  , v1GeneralDataAssetId = Nothing
  , v1GeneralDataSymbolId = Nothing
  , v1GeneralDataMetricId = Nothing
  , v1GeneralDataValueDecimal = Nothing
  , v1GeneralDataValueText = Nothing
  , v1GeneralDataValueTime = Nothing
  }

-- ** V1Icon
-- | V1Icon
-- Represents an icon.
data V1Icon = V1Icon
  { v1IconExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Gets or sets the exchange ID associated with the icon.
  , v1IconAssetId :: !(Maybe Text) -- ^ "asset_id" - Gets or sets the asset ID associated with the icon.
  , v1IconUrl :: !(Maybe Text) -- ^ "url" - Gets or sets the URL of the icon.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Icon
instance A.FromJSON V1Icon where
  parseJSON = A.withObject "V1Icon" $ \o ->
    V1Icon
      <$> (o .:? "exchange_id")
      <*> (o .:? "asset_id")
      <*> (o .:? "url")

-- | ToJSON V1Icon
instance A.ToJSON V1Icon where
  toJSON V1Icon {..} =
   _omitNulls
      [ "exchange_id" .= v1IconExchangeId
      , "asset_id" .= v1IconAssetId
      , "url" .= v1IconUrl
      ]


-- | Construct a value of type 'V1Icon' (by applying it's required fields, if any)
mkV1Icon
  :: V1Icon
mkV1Icon =
  V1Icon
  { v1IconExchangeId = Nothing
  , v1IconAssetId = Nothing
  , v1IconUrl = Nothing
  }

-- ** V1LastTrade
-- | V1LastTrade
-- Represents the last executed transaction.
data V1LastTrade = V1LastTrade
  { v1LastTradeTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The exchange time of the last trade.
  , v1LastTradeTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The CoinAPI time when the last trade was received.
  , v1LastTradeUuid :: !(Maybe Text) -- ^ "uuid" - The UUID of the last trade.
  , v1LastTradePrice :: !(Maybe Double) -- ^ "price" - The price of the last trade.
  , v1LastTradeSize :: !(Maybe Double) -- ^ "size" - The size of the last trade.
  , v1LastTradeTakerSide :: !(Maybe Text) -- ^ "taker_side" - The taker side of the last trade.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1LastTrade
instance A.FromJSON V1LastTrade where
  parseJSON = A.withObject "V1LastTrade" $ \o ->
    V1LastTrade
      <$> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "uuid")
      <*> (o .:? "price")
      <*> (o .:? "size")
      <*> (o .:? "taker_side")

-- | ToJSON V1LastTrade
instance A.ToJSON V1LastTrade where
  toJSON V1LastTrade {..} =
   _omitNulls
      [ "time_exchange" .= v1LastTradeTimeExchange
      , "time_coinapi" .= v1LastTradeTimeCoinapi
      , "uuid" .= v1LastTradeUuid
      , "price" .= v1LastTradePrice
      , "size" .= v1LastTradeSize
      , "taker_side" .= v1LastTradeTakerSide
      ]


-- | Construct a value of type 'V1LastTrade' (by applying it's required fields, if any)
mkV1LastTrade
  :: V1LastTrade
mkV1LastTrade =
  V1LastTrade
  { v1LastTradeTimeExchange = Nothing
  , v1LastTradeTimeCoinapi = Nothing
  , v1LastTradeUuid = Nothing
  , v1LastTradePrice = Nothing
  , v1LastTradeSize = Nothing
  , v1LastTradeTakerSide = Nothing
  }

-- ** V1ListingItem
-- | V1ListingItem
-- Represents a listing item.
data V1ListingItem = V1ListingItem
  { v1ListingItemMetricId :: !(Maybe Text) -- ^ "metric_id" - Gets or sets the metric ID.
  , v1ListingItemSymbolId :: !(Maybe Text) -- ^ "symbol_id" - Gets or sets the symbol ID.
  , v1ListingItemSymbolIdExternal :: !(Maybe Text) -- ^ "symbol_id_external" - Gets or sets the symbol ID from the exchange.
  , v1ListingItemExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Gets or sets the exchange ID.
  , v1ListingItemAssetId :: !(Maybe Text) -- ^ "asset_id" - Gets or sets the asset ID.
  , v1ListingItemAssetIdExternal :: !(Maybe Text) -- ^ "asset_id_external" - Gets or sets the asset ID from the exchange.
  , v1ListingItemChainId :: !(Maybe Text) -- ^ "chain_id" - Gets or sets the chain id.
  , v1ListingItemNetworkId :: !(Maybe Text) -- ^ "network_id" - Gets or sets the network id.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1ListingItem
instance A.FromJSON V1ListingItem where
  parseJSON = A.withObject "V1ListingItem" $ \o ->
    V1ListingItem
      <$> (o .:? "metric_id")
      <*> (o .:? "symbol_id")
      <*> (o .:? "symbol_id_external")
      <*> (o .:? "exchange_id")
      <*> (o .:? "asset_id")
      <*> (o .:? "asset_id_external")
      <*> (o .:? "chain_id")
      <*> (o .:? "network_id")

-- | ToJSON V1ListingItem
instance A.ToJSON V1ListingItem where
  toJSON V1ListingItem {..} =
   _omitNulls
      [ "metric_id" .= v1ListingItemMetricId
      , "symbol_id" .= v1ListingItemSymbolId
      , "symbol_id_external" .= v1ListingItemSymbolIdExternal
      , "exchange_id" .= v1ListingItemExchangeId
      , "asset_id" .= v1ListingItemAssetId
      , "asset_id_external" .= v1ListingItemAssetIdExternal
      , "chain_id" .= v1ListingItemChainId
      , "network_id" .= v1ListingItemNetworkId
      ]


-- | Construct a value of type 'V1ListingItem' (by applying it's required fields, if any)
mkV1ListingItem
  :: V1ListingItem
mkV1ListingItem =
  V1ListingItem
  { v1ListingItemMetricId = Nothing
  , v1ListingItemSymbolId = Nothing
  , v1ListingItemSymbolIdExternal = Nothing
  , v1ListingItemExchangeId = Nothing
  , v1ListingItemAssetId = Nothing
  , v1ListingItemAssetIdExternal = Nothing
  , v1ListingItemChainId = Nothing
  , v1ListingItemNetworkId = Nothing
  }

-- ** V1Metric
-- | V1Metric
-- Represents a metric.
data V1Metric = V1Metric
  { v1MetricMetricId :: !(Maybe Text) -- ^ "metric_id" - Gets or sets the metric ID.
  , v1MetricDescription :: !(Maybe Text) -- ^ "description" - Gets or sets the metric description.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Metric
instance A.FromJSON V1Metric where
  parseJSON = A.withObject "V1Metric" $ \o ->
    V1Metric
      <$> (o .:? "metric_id")
      <*> (o .:? "description")

-- | ToJSON V1Metric
instance A.ToJSON V1Metric where
  toJSON V1Metric {..} =
   _omitNulls
      [ "metric_id" .= v1MetricMetricId
      , "description" .= v1MetricDescription
      ]


-- | Construct a value of type 'V1Metric' (by applying it's required fields, if any)
mkV1Metric
  :: V1Metric
mkV1Metric =
  V1Metric
  { v1MetricMetricId = Nothing
  , v1MetricDescription = Nothing
  }

-- ** V1MetricData
-- | V1MetricData
-- Represents a data model for metric data.
data V1MetricData = V1MetricData
  { v1MetricDataSymbolId :: !(Maybe Text) -- ^ "symbol_id" - Gets or sets the symbol id.
  , v1MetricDataTime :: !(Maybe DateTime) -- ^ "time" - Gets or sets the time at which the value is recorded.
  , v1MetricDataValue :: !(Maybe Double) -- ^ "value" - Gets or sets the value of the metric.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1MetricData
instance A.FromJSON V1MetricData where
  parseJSON = A.withObject "V1MetricData" $ \o ->
    V1MetricData
      <$> (o .:? "symbol_id")
      <*> (o .:? "time")
      <*> (o .:? "value")

-- | ToJSON V1MetricData
instance A.ToJSON V1MetricData where
  toJSON V1MetricData {..} =
   _omitNulls
      [ "symbol_id" .= v1MetricDataSymbolId
      , "time" .= v1MetricDataTime
      , "value" .= v1MetricDataValue
      ]


-- | Construct a value of type 'V1MetricData' (by applying it's required fields, if any)
mkV1MetricData
  :: V1MetricData
mkV1MetricData =
  V1MetricData
  { v1MetricDataSymbolId = Nothing
  , v1MetricDataTime = Nothing
  , v1MetricDataValue = Nothing
  }

-- ** V1MetricInfo
-- | V1MetricInfo
-- Represents a metric information.
data V1MetricInfo = V1MetricInfo
  { v1MetricInfoMetricId :: !(Maybe Text) -- ^ "metric_id" - Gets or sets the metric identifier.
  , v1MetricInfoDescription :: !(Maybe Text) -- ^ "description" - Gets or sets the description of the metric.
  , v1MetricInfoSourceId :: !(Maybe Text) -- ^ "source_id" - Gets or sets the source identifier of the metric.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1MetricInfo
instance A.FromJSON V1MetricInfo where
  parseJSON = A.withObject "V1MetricInfo" $ \o ->
    V1MetricInfo
      <$> (o .:? "metric_id")
      <*> (o .:? "description")
      <*> (o .:? "source_id")

-- | ToJSON V1MetricInfo
instance A.ToJSON V1MetricInfo where
  toJSON V1MetricInfo {..} =
   _omitNulls
      [ "metric_id" .= v1MetricInfoMetricId
      , "description" .= v1MetricInfoDescription
      , "source_id" .= v1MetricInfoSourceId
      ]


-- | Construct a value of type 'V1MetricInfo' (by applying it's required fields, if any)
mkV1MetricInfo
  :: V1MetricInfo
mkV1MetricInfo =
  V1MetricInfo
  { v1MetricInfoMetricId = Nothing
  , v1MetricInfoDescription = Nothing
  , v1MetricInfoSourceId = Nothing
  }

-- ** V1OrderBook
-- | V1OrderBook
-- Represents an order book with additional information and functionality.
data V1OrderBook = V1OrderBook
  { v1OrderBookSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1OrderBookTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The exchange time of the order book.
  , v1OrderBookTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The CoinAPI time when the order book was received.
  , v1OrderBookAsks :: !(Maybe AnyType) -- ^ "asks" - The asks made by market makers.
  , v1OrderBookBids :: !(Maybe AnyType) -- ^ "bids" - The bids made by market makers.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1OrderBook
instance A.FromJSON V1OrderBook where
  parseJSON = A.withObject "V1OrderBook" $ \o ->
    V1OrderBook
      <$> (o .:? "symbol_id")
      <*> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "asks")
      <*> (o .:? "bids")

-- | ToJSON V1OrderBook
instance A.ToJSON V1OrderBook where
  toJSON V1OrderBook {..} =
   _omitNulls
      [ "symbol_id" .= v1OrderBookSymbolId
      , "time_exchange" .= v1OrderBookTimeExchange
      , "time_coinapi" .= v1OrderBookTimeCoinapi
      , "asks" .= v1OrderBookAsks
      , "bids" .= v1OrderBookBids
      ]


-- | Construct a value of type 'V1OrderBook' (by applying it's required fields, if any)
mkV1OrderBook
  :: V1OrderBook
mkV1OrderBook =
  V1OrderBook
  { v1OrderBookSymbolId = Nothing
  , v1OrderBookTimeExchange = Nothing
  , v1OrderBookTimeCoinapi = Nothing
  , v1OrderBookAsks = Nothing
  , v1OrderBookBids = Nothing
  }

-- ** V1OrderBookBase
-- | V1OrderBookBase
-- Represents the base model for order book data.
data V1OrderBookBase = V1OrderBookBase
  { v1OrderBookBaseSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1OrderBookBaseTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The exchange time of the order book.
  , v1OrderBookBaseTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The CoinAPI time when the order book was received.
  , v1OrderBookBaseAsks :: !(Maybe AnyType) -- ^ "asks" - The asks made by market makers.
  , v1OrderBookBaseBids :: !(Maybe AnyType) -- ^ "bids" - The bids made by market makers.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1OrderBookBase
instance A.FromJSON V1OrderBookBase where
  parseJSON = A.withObject "V1OrderBookBase" $ \o ->
    V1OrderBookBase
      <$> (o .:? "symbol_id")
      <*> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "asks")
      <*> (o .:? "bids")

-- | ToJSON V1OrderBookBase
instance A.ToJSON V1OrderBookBase where
  toJSON V1OrderBookBase {..} =
   _omitNulls
      [ "symbol_id" .= v1OrderBookBaseSymbolId
      , "time_exchange" .= v1OrderBookBaseTimeExchange
      , "time_coinapi" .= v1OrderBookBaseTimeCoinapi
      , "asks" .= v1OrderBookBaseAsks
      , "bids" .= v1OrderBookBaseBids
      ]


-- | Construct a value of type 'V1OrderBookBase' (by applying it's required fields, if any)
mkV1OrderBookBase
  :: V1OrderBookBase
mkV1OrderBookBase =
  V1OrderBookBase
  { v1OrderBookBaseSymbolId = Nothing
  , v1OrderBookBaseTimeExchange = Nothing
  , v1OrderBookBaseTimeCoinapi = Nothing
  , v1OrderBookBaseAsks = Nothing
  , v1OrderBookBaseBids = Nothing
  }

-- ** V1OrderBookDepth
-- | V1OrderBookDepth
-- Represents the depth of an order book.
data V1OrderBookDepth = V1OrderBookDepth
  { v1OrderBookDepthSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1OrderBookDepthTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The exchange time of the order book.
  , v1OrderBookDepthTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The CoinAPI time when the order book was received.
  , v1OrderBookDepthAskLevels :: !(Maybe Integer) -- ^ "ask_levels" - The number of ask levels in the order book.
  , v1OrderBookDepthBidLevels :: !(Maybe Integer) -- ^ "bid_levels" - The number of bid levels in the order book.
  , v1OrderBookDepthAskDepth :: !(Maybe Double) -- ^ "ask_depth" - The depth of the ask side of the order book.
  , v1OrderBookDepthBidDepth :: !(Maybe Double) -- ^ "bid_depth" - The depth of the bid side of the order book.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1OrderBookDepth
instance A.FromJSON V1OrderBookDepth where
  parseJSON = A.withObject "V1OrderBookDepth" $ \o ->
    V1OrderBookDepth
      <$> (o .:? "symbol_id")
      <*> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "ask_levels")
      <*> (o .:? "bid_levels")
      <*> (o .:? "ask_depth")
      <*> (o .:? "bid_depth")

-- | ToJSON V1OrderBookDepth
instance A.ToJSON V1OrderBookDepth where
  toJSON V1OrderBookDepth {..} =
   _omitNulls
      [ "symbol_id" .= v1OrderBookDepthSymbolId
      , "time_exchange" .= v1OrderBookDepthTimeExchange
      , "time_coinapi" .= v1OrderBookDepthTimeCoinapi
      , "ask_levels" .= v1OrderBookDepthAskLevels
      , "bid_levels" .= v1OrderBookDepthBidLevels
      , "ask_depth" .= v1OrderBookDepthAskDepth
      , "bid_depth" .= v1OrderBookDepthBidDepth
      ]


-- | Construct a value of type 'V1OrderBookDepth' (by applying it's required fields, if any)
mkV1OrderBookDepth
  :: V1OrderBookDepth
mkV1OrderBookDepth =
  V1OrderBookDepth
  { v1OrderBookDepthSymbolId = Nothing
  , v1OrderBookDepthTimeExchange = Nothing
  , v1OrderBookDepthTimeCoinapi = Nothing
  , v1OrderBookDepthAskLevels = Nothing
  , v1OrderBookDepthBidLevels = Nothing
  , v1OrderBookDepthAskDepth = Nothing
  , v1OrderBookDepthBidDepth = Nothing
  }

-- ** V1Quote
-- | V1Quote
-- Represents a quote data model.
data V1Quote = V1Quote
  { v1QuoteSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1QuoteTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The exchange time of the quote.
  , v1QuoteTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The CoinAPI time when the quote was received.
  , v1QuoteAskPrice :: !(Maybe Double) -- ^ "ask_price" - The best asking price.
  , v1QuoteAskSize :: !(Maybe Double) -- ^ "ask_size" - The volume resting on the best ask. If the value is equal to zero, then the size is unknown.
  , v1QuoteBidPrice :: !(Maybe Double) -- ^ "bid_price" - The best bidding price.
  , v1QuoteBidSize :: !(Maybe Double) -- ^ "bid_size" - The volume resting on the best bid. If the value is equal to zero, then the size is unknown.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Quote
instance A.FromJSON V1Quote where
  parseJSON = A.withObject "V1Quote" $ \o ->
    V1Quote
      <$> (o .:? "symbol_id")
      <*> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "ask_price")
      <*> (o .:? "ask_size")
      <*> (o .:? "bid_price")
      <*> (o .:? "bid_size")

-- | ToJSON V1Quote
instance A.ToJSON V1Quote where
  toJSON V1Quote {..} =
   _omitNulls
      [ "symbol_id" .= v1QuoteSymbolId
      , "time_exchange" .= v1QuoteTimeExchange
      , "time_coinapi" .= v1QuoteTimeCoinapi
      , "ask_price" .= v1QuoteAskPrice
      , "ask_size" .= v1QuoteAskSize
      , "bid_price" .= v1QuoteBidPrice
      , "bid_size" .= v1QuoteBidSize
      ]


-- | Construct a value of type 'V1Quote' (by applying it's required fields, if any)
mkV1Quote
  :: V1Quote
mkV1Quote =
  V1Quote
  { v1QuoteSymbolId = Nothing
  , v1QuoteTimeExchange = Nothing
  , v1QuoteTimeCoinapi = Nothing
  , v1QuoteAskPrice = Nothing
  , v1QuoteAskSize = Nothing
  , v1QuoteBidPrice = Nothing
  , v1QuoteBidSize = Nothing
  }

-- ** V1QuoteTrade
-- | V1QuoteTrade
-- Represents a quote trade data model.
data V1QuoteTrade = V1QuoteTrade
  { v1QuoteTradeSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1QuoteTradeTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The exchange time of the quote trade.
  , v1QuoteTradeTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The CoinAPI time when the quote trade was received.
  , v1QuoteTradeAskPrice :: !(Maybe Double) -- ^ "ask_price" - The best asking price.
  , v1QuoteTradeAskSize :: !(Maybe Double) -- ^ "ask_size" - The volume resting on the best ask. If the value is equal to zero, then the size is unknown.
  , v1QuoteTradeBidPrice :: !(Maybe Double) -- ^ "bid_price" - The best bidding price.
  , v1QuoteTradeBidSize :: !(Maybe Double) -- ^ "bid_size" - The volume resting on the best bid. If the value is equal to zero, then the size is unknown.
  , v1QuoteTradeLastTrade :: !(Maybe V1LastTrade) -- ^ "last_trade"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1QuoteTrade
instance A.FromJSON V1QuoteTrade where
  parseJSON = A.withObject "V1QuoteTrade" $ \o ->
    V1QuoteTrade
      <$> (o .:? "symbol_id")
      <*> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "ask_price")
      <*> (o .:? "ask_size")
      <*> (o .:? "bid_price")
      <*> (o .:? "bid_size")
      <*> (o .:? "last_trade")

-- | ToJSON V1QuoteTrade
instance A.ToJSON V1QuoteTrade where
  toJSON V1QuoteTrade {..} =
   _omitNulls
      [ "symbol_id" .= v1QuoteTradeSymbolId
      , "time_exchange" .= v1QuoteTradeTimeExchange
      , "time_coinapi" .= v1QuoteTradeTimeCoinapi
      , "ask_price" .= v1QuoteTradeAskPrice
      , "ask_size" .= v1QuoteTradeAskSize
      , "bid_price" .= v1QuoteTradeBidPrice
      , "bid_size" .= v1QuoteTradeBidSize
      , "last_trade" .= v1QuoteTradeLastTrade
      ]


-- | Construct a value of type 'V1QuoteTrade' (by applying it's required fields, if any)
mkV1QuoteTrade
  :: V1QuoteTrade
mkV1QuoteTrade =
  V1QuoteTrade
  { v1QuoteTradeSymbolId = Nothing
  , v1QuoteTradeTimeExchange = Nothing
  , v1QuoteTradeTimeCoinapi = Nothing
  , v1QuoteTradeAskPrice = Nothing
  , v1QuoteTradeAskSize = Nothing
  , v1QuoteTradeBidPrice = Nothing
  , v1QuoteTradeBidSize = Nothing
  , v1QuoteTradeLastTrade = Nothing
  }

-- ** V1Symbol
-- | V1Symbol
-- Represents a symbol data model.
data V1Symbol = V1Symbol
  { v1SymbolSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1SymbolExchangeId :: !(Maybe Text) -- ^ "exchange_id" - The exchange identifier.
  , v1SymbolSymbolType :: !(Maybe Text) -- ^ "symbol_type" - The symbol type.
  , v1SymbolAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - The base asset identifier.
  , v1SymbolAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - The quote asset identifier.
  , v1SymbolAssetIdUnit :: !(Maybe Text) -- ^ "asset_id_unit" - The unit asset identifier.
  , v1SymbolFutureContractUnit :: !(Maybe Double) -- ^ "future_contract_unit" - The contract unit for futures.
  , v1SymbolFutureContractUnitAsset :: !(Maybe Text) -- ^ "future_contract_unit_asset" - The asset used as the unit for futures contract.
  , v1SymbolFutureDeliveryTime :: !(Maybe DateTime) -- ^ "future_delivery_time" - The future delivery time for futures contract.
  , v1SymbolOptionTypeIsCall :: !(Maybe Bool) -- ^ "option_type_is_call" - Indicates whether the option type is a call.
  , v1SymbolOptionStrikePrice :: !(Maybe Double) -- ^ "option_strike_price" - The strike price for options.
  , v1SymbolOptionContractUnit :: !(Maybe Double) -- ^ "option_contract_unit" - The contract unit for options.
  , v1SymbolOptionExerciseStyle :: !(Maybe Text) -- ^ "option_exercise_style" - The exercise style for options.
  , v1SymbolOptionExpirationTime :: !(Maybe DateTime) -- ^ "option_expiration_time" - The expiration time for options.
  , v1SymbolContractDeliveryTime :: !(Maybe DateTime) -- ^ "contract_delivery_time" - The delivery time for contracts.
  , v1SymbolContractUnit :: !(Maybe Double) -- ^ "contract_unit" - The contract unit for contracts.
  , v1SymbolContractUnitAsset :: !(Maybe Text) -- ^ "contract_unit_asset" - The asset used as the unit for contracts.
  , v1SymbolContractId :: !(Maybe Text) -- ^ "contract_id" - The contract identifier.
  , v1SymbolContractDisplayName :: !(Maybe Text) -- ^ "contract_display_name" - The display name of the contract.
  , v1SymbolContractDisplayDescription :: !(Maybe Text) -- ^ "contract_display_description" - The display description of the contract.
  , v1SymbolDataStart :: !(Maybe Text) -- ^ /ReadOnly/ "data_start"
  , v1SymbolDataEnd :: !(Maybe Text) -- ^ /ReadOnly/ "data_end"
  , v1SymbolDataQuoteStart :: !(Maybe DateTime) -- ^ "data_quote_start" - The start date of quote data.
  , v1SymbolDataQuoteEnd :: !(Maybe DateTime) -- ^ "data_quote_end" - The end date of quote data.
  , v1SymbolDataOrderbookStart :: !(Maybe DateTime) -- ^ "data_orderbook_start" - The start date of order book data.
  , v1SymbolDataOrderbookEnd :: !(Maybe DateTime) -- ^ "data_orderbook_end" - The end date of order book data.
  , v1SymbolDataTradeStart :: !(Maybe DateTime) -- ^ "data_trade_start" - The start date of trade data.
  , v1SymbolDataTradeEnd :: !(Maybe DateTime) -- ^ "data_trade_end" - The end date of trade data.
  , v1SymbolIndexId :: !(Maybe Text) -- ^ "index_id" - The index identifier.
  , v1SymbolIndexDisplayName :: !(Maybe Text) -- ^ "index_display_name" - The display name of the index.
  , v1SymbolIndexDisplayDescription :: !(Maybe Text) -- ^ "index_display_description" - The display description of the index.
  , v1SymbolVolume1hrs :: !(Maybe Double) -- ^ "volume_1hrs" - The volume in the last 1 hour.
  , v1SymbolVolume1hrsUsd :: !(Maybe Double) -- ^ "volume_1hrs_usd" - The volume in USD in the last 1 hour.
  , v1SymbolVolume1day :: !(Maybe Double) -- ^ "volume_1day" - The volume in the last 1 day.
  , v1SymbolVolume1dayUsd :: !(Maybe Double) -- ^ "volume_1day_usd" - The volume in USD in the last 1 day.
  , v1SymbolVolume1mth :: !(Maybe Double) -- ^ "volume_1mth" - The volume in the last 1 month.
  , v1SymbolVolume1mthUsd :: !(Maybe Double) -- ^ "volume_1mth_usd" - The volume in USD in the last 1 month.
  , v1SymbolPrice :: !(Maybe Double) -- ^ "price" - The price.
  , v1SymbolSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - The symbol identifier in the exchange.
  , v1SymbolAssetIdBaseExchange :: !(Maybe Text) -- ^ "asset_id_base_exchange" - The base asset identifier in the exchange.
  , v1SymbolAssetIdQuoteExchange :: !(Maybe Text) -- ^ "asset_id_quote_exchange" - The quote asset identifier in the exchange.
  , v1SymbolPricePrecision :: !(Maybe Double) -- ^ "price_precision" - The price precision.
  , v1SymbolSizePrecision :: !(Maybe Double) -- ^ "size_precision" - The size precision.
  , v1SymbolRawKvp :: !(Maybe (Map.Map String Text)) -- ^ "raw_kvp" - Not normalized raw kvp data.
  , v1SymbolVolumeToUsd :: !(Maybe Double) -- ^ "volume_to_usd" - Volume unit in USD.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Symbol
instance A.FromJSON V1Symbol where
  parseJSON = A.withObject "V1Symbol" $ \o ->
    V1Symbol
      <$> (o .:? "symbol_id")
      <*> (o .:? "exchange_id")
      <*> (o .:? "symbol_type")
      <*> (o .:? "asset_id_base")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "asset_id_unit")
      <*> (o .:? "future_contract_unit")
      <*> (o .:? "future_contract_unit_asset")
      <*> (o .:? "future_delivery_time")
      <*> (o .:? "option_type_is_call")
      <*> (o .:? "option_strike_price")
      <*> (o .:? "option_contract_unit")
      <*> (o .:? "option_exercise_style")
      <*> (o .:? "option_expiration_time")
      <*> (o .:? "contract_delivery_time")
      <*> (o .:? "contract_unit")
      <*> (o .:? "contract_unit_asset")
      <*> (o .:? "contract_id")
      <*> (o .:? "contract_display_name")
      <*> (o .:? "contract_display_description")
      <*> (o .:? "data_start")
      <*> (o .:? "data_end")
      <*> (o .:? "data_quote_start")
      <*> (o .:? "data_quote_end")
      <*> (o .:? "data_orderbook_start")
      <*> (o .:? "data_orderbook_end")
      <*> (o .:? "data_trade_start")
      <*> (o .:? "data_trade_end")
      <*> (o .:? "index_id")
      <*> (o .:? "index_display_name")
      <*> (o .:? "index_display_description")
      <*> (o .:? "volume_1hrs")
      <*> (o .:? "volume_1hrs_usd")
      <*> (o .:? "volume_1day")
      <*> (o .:? "volume_1day_usd")
      <*> (o .:? "volume_1mth")
      <*> (o .:? "volume_1mth_usd")
      <*> (o .:? "price")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "asset_id_base_exchange")
      <*> (o .:? "asset_id_quote_exchange")
      <*> (o .:? "price_precision")
      <*> (o .:? "size_precision")
      <*> (o .:? "raw_kvp")
      <*> (o .:? "volume_to_usd")

-- | ToJSON V1Symbol
instance A.ToJSON V1Symbol where
  toJSON V1Symbol {..} =
   _omitNulls
      [ "symbol_id" .= v1SymbolSymbolId
      , "exchange_id" .= v1SymbolExchangeId
      , "symbol_type" .= v1SymbolSymbolType
      , "asset_id_base" .= v1SymbolAssetIdBase
      , "asset_id_quote" .= v1SymbolAssetIdQuote
      , "asset_id_unit" .= v1SymbolAssetIdUnit
      , "future_contract_unit" .= v1SymbolFutureContractUnit
      , "future_contract_unit_asset" .= v1SymbolFutureContractUnitAsset
      , "future_delivery_time" .= v1SymbolFutureDeliveryTime
      , "option_type_is_call" .= v1SymbolOptionTypeIsCall
      , "option_strike_price" .= v1SymbolOptionStrikePrice
      , "option_contract_unit" .= v1SymbolOptionContractUnit
      , "option_exercise_style" .= v1SymbolOptionExerciseStyle
      , "option_expiration_time" .= v1SymbolOptionExpirationTime
      , "contract_delivery_time" .= v1SymbolContractDeliveryTime
      , "contract_unit" .= v1SymbolContractUnit
      , "contract_unit_asset" .= v1SymbolContractUnitAsset
      , "contract_id" .= v1SymbolContractId
      , "contract_display_name" .= v1SymbolContractDisplayName
      , "contract_display_description" .= v1SymbolContractDisplayDescription
      , "data_start" .= v1SymbolDataStart
      , "data_end" .= v1SymbolDataEnd
      , "data_quote_start" .= v1SymbolDataQuoteStart
      , "data_quote_end" .= v1SymbolDataQuoteEnd
      , "data_orderbook_start" .= v1SymbolDataOrderbookStart
      , "data_orderbook_end" .= v1SymbolDataOrderbookEnd
      , "data_trade_start" .= v1SymbolDataTradeStart
      , "data_trade_end" .= v1SymbolDataTradeEnd
      , "index_id" .= v1SymbolIndexId
      , "index_display_name" .= v1SymbolIndexDisplayName
      , "index_display_description" .= v1SymbolIndexDisplayDescription
      , "volume_1hrs" .= v1SymbolVolume1hrs
      , "volume_1hrs_usd" .= v1SymbolVolume1hrsUsd
      , "volume_1day" .= v1SymbolVolume1day
      , "volume_1day_usd" .= v1SymbolVolume1dayUsd
      , "volume_1mth" .= v1SymbolVolume1mth
      , "volume_1mth_usd" .= v1SymbolVolume1mthUsd
      , "price" .= v1SymbolPrice
      , "symbol_id_exchange" .= v1SymbolSymbolIdExchange
      , "asset_id_base_exchange" .= v1SymbolAssetIdBaseExchange
      , "asset_id_quote_exchange" .= v1SymbolAssetIdQuoteExchange
      , "price_precision" .= v1SymbolPricePrecision
      , "size_precision" .= v1SymbolSizePrecision
      , "raw_kvp" .= v1SymbolRawKvp
      , "volume_to_usd" .= v1SymbolVolumeToUsd
      ]


-- | Construct a value of type 'V1Symbol' (by applying it's required fields, if any)
mkV1Symbol
  :: V1Symbol
mkV1Symbol =
  V1Symbol
  { v1SymbolSymbolId = Nothing
  , v1SymbolExchangeId = Nothing
  , v1SymbolSymbolType = Nothing
  , v1SymbolAssetIdBase = Nothing
  , v1SymbolAssetIdQuote = Nothing
  , v1SymbolAssetIdUnit = Nothing
  , v1SymbolFutureContractUnit = Nothing
  , v1SymbolFutureContractUnitAsset = Nothing
  , v1SymbolFutureDeliveryTime = Nothing
  , v1SymbolOptionTypeIsCall = Nothing
  , v1SymbolOptionStrikePrice = Nothing
  , v1SymbolOptionContractUnit = Nothing
  , v1SymbolOptionExerciseStyle = Nothing
  , v1SymbolOptionExpirationTime = Nothing
  , v1SymbolContractDeliveryTime = Nothing
  , v1SymbolContractUnit = Nothing
  , v1SymbolContractUnitAsset = Nothing
  , v1SymbolContractId = Nothing
  , v1SymbolContractDisplayName = Nothing
  , v1SymbolContractDisplayDescription = Nothing
  , v1SymbolDataStart = Nothing
  , v1SymbolDataEnd = Nothing
  , v1SymbolDataQuoteStart = Nothing
  , v1SymbolDataQuoteEnd = Nothing
  , v1SymbolDataOrderbookStart = Nothing
  , v1SymbolDataOrderbookEnd = Nothing
  , v1SymbolDataTradeStart = Nothing
  , v1SymbolDataTradeEnd = Nothing
  , v1SymbolIndexId = Nothing
  , v1SymbolIndexDisplayName = Nothing
  , v1SymbolIndexDisplayDescription = Nothing
  , v1SymbolVolume1hrs = Nothing
  , v1SymbolVolume1hrsUsd = Nothing
  , v1SymbolVolume1day = Nothing
  , v1SymbolVolume1dayUsd = Nothing
  , v1SymbolVolume1mth = Nothing
  , v1SymbolVolume1mthUsd = Nothing
  , v1SymbolPrice = Nothing
  , v1SymbolSymbolIdExchange = Nothing
  , v1SymbolAssetIdBaseExchange = Nothing
  , v1SymbolAssetIdQuoteExchange = Nothing
  , v1SymbolPricePrecision = Nothing
  , v1SymbolSizePrecision = Nothing
  , v1SymbolRawKvp = Nothing
  , v1SymbolVolumeToUsd = Nothing
  }

-- ** V1SymbolMapping
-- | V1SymbolMapping
-- Represents symbol mapping information for exchange symbols.
data V1SymbolMapping = V1SymbolMapping
  { v1SymbolMappingSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol ID.
  , v1SymbolMappingSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - The exchange-specific symbol ID.
  , v1SymbolMappingCoinapiDatainfoId :: !(Maybe Int) -- ^ "coinapi_datainfo_id" - The CoinAPI DataInfo ID.
  , v1SymbolMappingAssetIdBaseExchange :: !(Maybe Text) -- ^ "asset_id_base_exchange" - The exchange-specific base asset ID.
  , v1SymbolMappingAssetIdQuoteExchange :: !(Maybe Text) -- ^ "asset_id_quote_exchange" - The exchange-specific quote asset ID.
  , v1SymbolMappingAssetIdBase :: !(Maybe Text) -- ^ "asset_id_base" - The base asset ID.
  , v1SymbolMappingAssetIdQuote :: !(Maybe Text) -- ^ "asset_id_quote" - The quote asset ID.
  , v1SymbolMappingPricePrecision :: !(Maybe Double) -- ^ "price_precision" - The price precision.
  , v1SymbolMappingSizePrecision :: !(Maybe Double) -- ^ "size_precision" - The size precision.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1SymbolMapping
instance A.FromJSON V1SymbolMapping where
  parseJSON = A.withObject "V1SymbolMapping" $ \o ->
    V1SymbolMapping
      <$> (o .:? "symbol_id")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "coinapi_datainfo_id")
      <*> (o .:? "asset_id_base_exchange")
      <*> (o .:? "asset_id_quote_exchange")
      <*> (o .:? "asset_id_base")
      <*> (o .:? "asset_id_quote")
      <*> (o .:? "price_precision")
      <*> (o .:? "size_precision")

-- | ToJSON V1SymbolMapping
instance A.ToJSON V1SymbolMapping where
  toJSON V1SymbolMapping {..} =
   _omitNulls
      [ "symbol_id" .= v1SymbolMappingSymbolId
      , "symbol_id_exchange" .= v1SymbolMappingSymbolIdExchange
      , "coinapi_datainfo_id" .= v1SymbolMappingCoinapiDatainfoId
      , "asset_id_base_exchange" .= v1SymbolMappingAssetIdBaseExchange
      , "asset_id_quote_exchange" .= v1SymbolMappingAssetIdQuoteExchange
      , "asset_id_base" .= v1SymbolMappingAssetIdBase
      , "asset_id_quote" .= v1SymbolMappingAssetIdQuote
      , "price_precision" .= v1SymbolMappingPricePrecision
      , "size_precision" .= v1SymbolMappingSizePrecision
      ]


-- | Construct a value of type 'V1SymbolMapping' (by applying it's required fields, if any)
mkV1SymbolMapping
  :: V1SymbolMapping
mkV1SymbolMapping =
  V1SymbolMapping
  { v1SymbolMappingSymbolId = Nothing
  , v1SymbolMappingSymbolIdExchange = Nothing
  , v1SymbolMappingCoinapiDatainfoId = Nothing
  , v1SymbolMappingAssetIdBaseExchange = Nothing
  , v1SymbolMappingAssetIdQuoteExchange = Nothing
  , v1SymbolMappingAssetIdBase = Nothing
  , v1SymbolMappingAssetIdQuote = Nothing
  , v1SymbolMappingPricePrecision = Nothing
  , v1SymbolMappingSizePrecision = Nothing
  }

-- ** V1TimeseriesItem
-- | V1TimeseriesItem
-- Represents a timeseries item with price and volume information.
data V1TimeseriesItem = V1TimeseriesItem
  { v1TimeseriesItemTimePeriodStart :: !(Maybe DateTime) -- ^ "time_period_start" - The start time of the time period.
  , v1TimeseriesItemTimePeriodEnd :: !(Maybe DateTime) -- ^ "time_period_end" - The end time of the time period.
  , v1TimeseriesItemTimeOpen :: !(Maybe DateTime) -- ^ "time_open" - The time when the price opened.
  , v1TimeseriesItemTimeClose :: !(Maybe DateTime) -- ^ "time_close" - The time when the price closed.
  , v1TimeseriesItemPriceOpen :: !(Maybe Double) -- ^ "price_open" - The opening price.
  , v1TimeseriesItemPriceHigh :: !(Maybe Double) -- ^ "price_high" - The highest price during the time period.
  , v1TimeseriesItemPriceLow :: !(Maybe Double) -- ^ "price_low" - The lowest price during the time period.
  , v1TimeseriesItemPriceClose :: !(Maybe Double) -- ^ "price_close" - The closing price.
  , v1TimeseriesItemVolumeTraded :: !(Maybe Double) -- ^ "volume_traded" - The total volume traded during the time period.
  , v1TimeseriesItemTradesCount :: !(Maybe Integer) -- ^ "trades_count" - The number of trades executed during the time period.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1TimeseriesItem
instance A.FromJSON V1TimeseriesItem where
  parseJSON = A.withObject "V1TimeseriesItem" $ \o ->
    V1TimeseriesItem
      <$> (o .:? "time_period_start")
      <*> (o .:? "time_period_end")
      <*> (o .:? "time_open")
      <*> (o .:? "time_close")
      <*> (o .:? "price_open")
      <*> (o .:? "price_high")
      <*> (o .:? "price_low")
      <*> (o .:? "price_close")
      <*> (o .:? "volume_traded")
      <*> (o .:? "trades_count")

-- | ToJSON V1TimeseriesItem
instance A.ToJSON V1TimeseriesItem where
  toJSON V1TimeseriesItem {..} =
   _omitNulls
      [ "time_period_start" .= v1TimeseriesItemTimePeriodStart
      , "time_period_end" .= v1TimeseriesItemTimePeriodEnd
      , "time_open" .= v1TimeseriesItemTimeOpen
      , "time_close" .= v1TimeseriesItemTimeClose
      , "price_open" .= v1TimeseriesItemPriceOpen
      , "price_high" .= v1TimeseriesItemPriceHigh
      , "price_low" .= v1TimeseriesItemPriceLow
      , "price_close" .= v1TimeseriesItemPriceClose
      , "volume_traded" .= v1TimeseriesItemVolumeTraded
      , "trades_count" .= v1TimeseriesItemTradesCount
      ]


-- | Construct a value of type 'V1TimeseriesItem' (by applying it's required fields, if any)
mkV1TimeseriesItem
  :: V1TimeseriesItem
mkV1TimeseriesItem =
  V1TimeseriesItem
  { v1TimeseriesItemTimePeriodStart = Nothing
  , v1TimeseriesItemTimePeriodEnd = Nothing
  , v1TimeseriesItemTimeOpen = Nothing
  , v1TimeseriesItemTimeClose = Nothing
  , v1TimeseriesItemPriceOpen = Nothing
  , v1TimeseriesItemPriceHigh = Nothing
  , v1TimeseriesItemPriceLow = Nothing
  , v1TimeseriesItemPriceClose = Nothing
  , v1TimeseriesItemVolumeTraded = Nothing
  , v1TimeseriesItemTradesCount = Nothing
  }

-- ** V1TimeseriesPeriod
-- | V1TimeseriesPeriod
-- Represents a timeseries period used in exchange rate data.
data V1TimeseriesPeriod = V1TimeseriesPeriod
  { v1TimeseriesPeriodPeriodId :: !(Maybe Text) -- ^ "period_id" - The period ID.
  , v1TimeseriesPeriodLengthSeconds :: !(Maybe Int) -- ^ "length_seconds" - The length of the period in seconds.
  , v1TimeseriesPeriodLengthMonths :: !(Maybe Int) -- ^ "length_months" - The length of the period in months.
  , v1TimeseriesPeriodUnitCount :: !(Maybe Int) -- ^ "unit_count" - The unit count.
  , v1TimeseriesPeriodUnitName :: !(Maybe Text) -- ^ "unit_name" - The unit name.
  , v1TimeseriesPeriodDisplayName :: !(Maybe Text) -- ^ "display_name" - The display name of the timeseries period.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1TimeseriesPeriod
instance A.FromJSON V1TimeseriesPeriod where
  parseJSON = A.withObject "V1TimeseriesPeriod" $ \o ->
    V1TimeseriesPeriod
      <$> (o .:? "period_id")
      <*> (o .:? "length_seconds")
      <*> (o .:? "length_months")
      <*> (o .:? "unit_count")
      <*> (o .:? "unit_name")
      <*> (o .:? "display_name")

-- | ToJSON V1TimeseriesPeriod
instance A.ToJSON V1TimeseriesPeriod where
  toJSON V1TimeseriesPeriod {..} =
   _omitNulls
      [ "period_id" .= v1TimeseriesPeriodPeriodId
      , "length_seconds" .= v1TimeseriesPeriodLengthSeconds
      , "length_months" .= v1TimeseriesPeriodLengthMonths
      , "unit_count" .= v1TimeseriesPeriodUnitCount
      , "unit_name" .= v1TimeseriesPeriodUnitName
      , "display_name" .= v1TimeseriesPeriodDisplayName
      ]


-- | Construct a value of type 'V1TimeseriesPeriod' (by applying it's required fields, if any)
mkV1TimeseriesPeriod
  :: V1TimeseriesPeriod
mkV1TimeseriesPeriod =
  V1TimeseriesPeriod
  { v1TimeseriesPeriodPeriodId = Nothing
  , v1TimeseriesPeriodLengthSeconds = Nothing
  , v1TimeseriesPeriodLengthMonths = Nothing
  , v1TimeseriesPeriodUnitCount = Nothing
  , v1TimeseriesPeriodUnitName = Nothing
  , v1TimeseriesPeriodDisplayName = Nothing
  }

-- ** V1Trade
-- | V1Trade
-- Represents a trade executed on the exchange.
data V1Trade = V1Trade
  { v1TradeSymbolId :: !(Maybe Text) -- ^ "symbol_id" - The symbol identifier.
  , v1TradeTimeExchange :: !(Maybe DateTime) -- ^ "time_exchange" - The time of trade reported by the exchange.
  , v1TradeTimeCoinapi :: !(Maybe DateTime) -- ^ "time_coinapi" - The time when the trade was received by CoinAPI.
  , v1TradeUuid :: !(Maybe Text) -- ^ "uuid" - The unique identifier for the trade.
  , v1TradePrice :: !(Maybe Double) -- ^ "price" - The price of the transaction.
  , v1TradeSize :: !(Maybe Double) -- ^ "size" - The base asset amount traded in the transaction.
  , v1TradeTakerSide :: !(Maybe Text) -- ^ "taker_side" - The aggressor side of the transaction (BUY/SELL/BUY_ESTIMATED/SELL_ESTIMATED/UNKNOWN).
  , v1TradeIdTrade :: !(Maybe Text) -- ^ "id_trade" - The trade identifier.
  , v1TradeIdOrderMaker :: !(Maybe Text) -- ^ "id_order_maker" - The order maker identifier.
  , v1TradeIdOrderTaker :: !(Maybe Text) -- ^ "id_order_taker" - The order taker identifier.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON V1Trade
instance A.FromJSON V1Trade where
  parseJSON = A.withObject "V1Trade" $ \o ->
    V1Trade
      <$> (o .:? "symbol_id")
      <*> (o .:? "time_exchange")
      <*> (o .:? "time_coinapi")
      <*> (o .:? "uuid")
      <*> (o .:? "price")
      <*> (o .:? "size")
      <*> (o .:? "taker_side")
      <*> (o .:? "id_trade")
      <*> (o .:? "id_order_maker")
      <*> (o .:? "id_order_taker")

-- | ToJSON V1Trade
instance A.ToJSON V1Trade where
  toJSON V1Trade {..} =
   _omitNulls
      [ "symbol_id" .= v1TradeSymbolId
      , "time_exchange" .= v1TradeTimeExchange
      , "time_coinapi" .= v1TradeTimeCoinapi
      , "uuid" .= v1TradeUuid
      , "price" .= v1TradePrice
      , "size" .= v1TradeSize
      , "taker_side" .= v1TradeTakerSide
      , "id_trade" .= v1TradeIdTrade
      , "id_order_maker" .= v1TradeIdOrderMaker
      , "id_order_taker" .= v1TradeIdOrderTaker
      ]


-- | Construct a value of type 'V1Trade' (by applying it's required fields, if any)
mkV1Trade
  :: V1Trade
mkV1Trade =
  V1Trade
  { v1TradeSymbolId = Nothing
  , v1TradeTimeExchange = Nothing
  , v1TradeTimeCoinapi = Nothing
  , v1TradeUuid = Nothing
  , v1TradePrice = Nothing
  , v1TradeSize = Nothing
  , v1TradeTakerSide = Nothing
  , v1TradeIdTrade = Nothing
  , v1TradeIdOrderMaker = Nothing
  , v1TradeIdOrderTaker = Nothing
  }




-- * Auth Methods

-- ** AuthApiKeyAPIKey
data AuthApiKeyAPIKey =
  AuthApiKeyAPIKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyAPIKey where
  applyAuthMethod _ a@(AuthApiKeyAPIKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


