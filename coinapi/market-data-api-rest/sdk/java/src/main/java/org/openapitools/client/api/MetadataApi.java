/*
 * REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.V1Asset;
import org.openapitools.client.model.V1Exchange;
import org.openapitools.client.model.V1Icon;
import org.openapitools.client.model.V1Symbol;
import org.openapitools.client.model.V1SymbolMapping;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MetadataApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MetadataApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MetadataApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for v1AssetsAssetIdGet
     * @param assetId The asset ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1AssetsAssetIdGetCall(@javax.annotation.Nonnull String assetId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/assets/{asset_id}"
            .replace("{" + "asset_id" + "}", localVarApiClient.escapeString(assetId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1AssetsAssetIdGetValidateBeforeCall(@javax.annotation.Nonnull String assetId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'assetId' is set
        if (assetId == null) {
            throw new ApiException("Missing the required parameter 'assetId' when calling v1AssetsAssetIdGet(Async)");
        }

        return v1AssetsAssetIdGetCall(assetId, _callback);

    }

    /**
     * List all assets by asset ID
     * 
     * @param assetId The asset ID. (required)
     * @return List&lt;V1Asset&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Asset> v1AssetsAssetIdGet(@javax.annotation.Nonnull String assetId) throws ApiException {
        ApiResponse<List<V1Asset>> localVarResp = v1AssetsAssetIdGetWithHttpInfo(assetId);
        return localVarResp.getData();
    }

    /**
     * List all assets by asset ID
     * 
     * @param assetId The asset ID. (required)
     * @return ApiResponse&lt;List&lt;V1Asset&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Asset>> v1AssetsAssetIdGetWithHttpInfo(@javax.annotation.Nonnull String assetId) throws ApiException {
        okhttp3.Call localVarCall = v1AssetsAssetIdGetValidateBeforeCall(assetId, null);
        Type localVarReturnType = new TypeToken<List<V1Asset>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all assets by asset ID (asynchronously)
     * 
     * @param assetId The asset ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1AssetsAssetIdGetAsync(@javax.annotation.Nonnull String assetId, final ApiCallback<List<V1Asset>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1AssetsAssetIdGetValidateBeforeCall(assetId, _callback);
        Type localVarReturnType = new TypeToken<List<V1Asset>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1AssetsGet
     * @param filterAssetId Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1AssetsGetCall(@javax.annotation.Nullable String filterAssetId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/assets";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filterAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_asset_id", filterAssetId));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1AssetsGetValidateBeforeCall(@javax.annotation.Nullable String filterAssetId, final ApiCallback _callback) throws ApiException {
        return v1AssetsGetCall(filterAssetId, _callback);

    }

    /**
     * List all assets
     * Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
     * @param filterAssetId Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)
     * @return List&lt;V1Asset&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Asset> v1AssetsGet(@javax.annotation.Nullable String filterAssetId) throws ApiException {
        ApiResponse<List<V1Asset>> localVarResp = v1AssetsGetWithHttpInfo(filterAssetId);
        return localVarResp.getData();
    }

    /**
     * List all assets
     * Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
     * @param filterAssetId Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)
     * @return ApiResponse&lt;List&lt;V1Asset&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Asset>> v1AssetsGetWithHttpInfo(@javax.annotation.Nullable String filterAssetId) throws ApiException {
        okhttp3.Call localVarCall = v1AssetsGetValidateBeforeCall(filterAssetId, null);
        Type localVarReturnType = new TypeToken<List<V1Asset>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all assets (asynchronously)
     * Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
     * @param filterAssetId Comma or semicolon delimited asset identifiers used to filter response. (optional, eg. &#x60;BTC;ETH&#x60;). (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1AssetsGetAsync(@javax.annotation.Nullable String filterAssetId, final ApiCallback<List<V1Asset>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1AssetsGetValidateBeforeCall(filterAssetId, _callback);
        Type localVarReturnType = new TypeToken<List<V1Asset>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1AssetsIconsSizeGet
     * @param size The size of the icons. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1AssetsIconsSizeGetCall(@javax.annotation.Nonnull Integer size, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/assets/icons/{size}"
            .replace("{" + "size" + "}", localVarApiClient.escapeString(size.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1AssetsIconsSizeGetValidateBeforeCall(@javax.annotation.Nonnull Integer size, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'size' is set
        if (size == null) {
            throw new ApiException("Missing the required parameter 'size' when calling v1AssetsIconsSizeGet(Async)");
        }

        return v1AssetsIconsSizeGetCall(size, _callback);

    }

    /**
     * List all asset icons
     * Gets the list of icons (of the given size) for all the assets.
     * @param size The size of the icons. (required)
     * @return List&lt;V1Icon&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Icon> v1AssetsIconsSizeGet(@javax.annotation.Nonnull Integer size) throws ApiException {
        ApiResponse<List<V1Icon>> localVarResp = v1AssetsIconsSizeGetWithHttpInfo(size);
        return localVarResp.getData();
    }

    /**
     * List all asset icons
     * Gets the list of icons (of the given size) for all the assets.
     * @param size The size of the icons. (required)
     * @return ApiResponse&lt;List&lt;V1Icon&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Icon>> v1AssetsIconsSizeGetWithHttpInfo(@javax.annotation.Nonnull Integer size) throws ApiException {
        okhttp3.Call localVarCall = v1AssetsIconsSizeGetValidateBeforeCall(size, null);
        Type localVarReturnType = new TypeToken<List<V1Icon>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all asset icons (asynchronously)
     * Gets the list of icons (of the given size) for all the assets.
     * @param size The size of the icons. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1AssetsIconsSizeGetAsync(@javax.annotation.Nonnull Integer size, final ApiCallback<List<V1Icon>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1AssetsIconsSizeGetValidateBeforeCall(size, _callback);
        Type localVarReturnType = new TypeToken<List<V1Icon>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1ExchangesExchangeIdGet
     * @param exchangeId The ID of the exchange. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1ExchangesExchangeIdGetCall(@javax.annotation.Nonnull String exchangeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/exchanges/{exchange_id}"
            .replace("{" + "exchange_id" + "}", localVarApiClient.escapeString(exchangeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1ExchangesExchangeIdGetValidateBeforeCall(@javax.annotation.Nonnull String exchangeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exchangeId' is set
        if (exchangeId == null) {
            throw new ApiException("Missing the required parameter 'exchangeId' when calling v1ExchangesExchangeIdGet(Async)");
        }

        return v1ExchangesExchangeIdGetCall(exchangeId, _callback);

    }

    /**
     * List all exchanges by exchange_id
     * 
     * @param exchangeId The ID of the exchange. (required)
     * @return List&lt;V1Exchange&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Exchange> v1ExchangesExchangeIdGet(@javax.annotation.Nonnull String exchangeId) throws ApiException {
        ApiResponse<List<V1Exchange>> localVarResp = v1ExchangesExchangeIdGetWithHttpInfo(exchangeId);
        return localVarResp.getData();
    }

    /**
     * List all exchanges by exchange_id
     * 
     * @param exchangeId The ID of the exchange. (required)
     * @return ApiResponse&lt;List&lt;V1Exchange&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Exchange>> v1ExchangesExchangeIdGetWithHttpInfo(@javax.annotation.Nonnull String exchangeId) throws ApiException {
        okhttp3.Call localVarCall = v1ExchangesExchangeIdGetValidateBeforeCall(exchangeId, null);
        Type localVarReturnType = new TypeToken<List<V1Exchange>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all exchanges by exchange_id (asynchronously)
     * 
     * @param exchangeId The ID of the exchange. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1ExchangesExchangeIdGetAsync(@javax.annotation.Nonnull String exchangeId, final ApiCallback<List<V1Exchange>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1ExchangesExchangeIdGetValidateBeforeCall(exchangeId, _callback);
        Type localVarReturnType = new TypeToken<List<V1Exchange>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1ExchangesGet
     * @param filterExchangeId Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1ExchangesGetCall(@javax.annotation.Nullable String filterExchangeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/exchanges";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filterExchangeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_exchange_id", filterExchangeId));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1ExchangesGetValidateBeforeCall(@javax.annotation.Nullable String filterExchangeId, final ApiCallback _callback) throws ApiException {
        return v1ExchangesGetCall(filterExchangeId, _callback);

    }

    /**
     * List all exchanges
     * Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
     * @param filterExchangeId Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)
     * @return List&lt;V1Exchange&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Exchange> v1ExchangesGet(@javax.annotation.Nullable String filterExchangeId) throws ApiException {
        ApiResponse<List<V1Exchange>> localVarResp = v1ExchangesGetWithHttpInfo(filterExchangeId);
        return localVarResp.getData();
    }

    /**
     * List all exchanges
     * Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
     * @param filterExchangeId Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)
     * @return ApiResponse&lt;List&lt;V1Exchange&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Exchange>> v1ExchangesGetWithHttpInfo(@javax.annotation.Nullable String filterExchangeId) throws ApiException {
        okhttp3.Call localVarCall = v1ExchangesGetValidateBeforeCall(filterExchangeId, null);
        Type localVarReturnType = new TypeToken<List<V1Exchange>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all exchanges (asynchronously)
     * Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
     * @param filterExchangeId Comma or semicolon delimited exchange identifiers used to filter response. (optional, eg. &#x60;BITSTAMP;GEMINI&#x60;) (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1ExchangesGetAsync(@javax.annotation.Nullable String filterExchangeId, final ApiCallback<List<V1Exchange>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1ExchangesGetValidateBeforeCall(filterExchangeId, _callback);
        Type localVarReturnType = new TypeToken<List<V1Exchange>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1ExchangesIconsSizeGet
     * @param size The size of the icons. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1ExchangesIconsSizeGetCall(@javax.annotation.Nonnull Integer size, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/exchanges/icons/{size}"
            .replace("{" + "size" + "}", localVarApiClient.escapeString(size.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1ExchangesIconsSizeGetValidateBeforeCall(@javax.annotation.Nonnull Integer size, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'size' is set
        if (size == null) {
            throw new ApiException("Missing the required parameter 'size' when calling v1ExchangesIconsSizeGet(Async)");
        }

        return v1ExchangesIconsSizeGetCall(size, _callback);

    }

    /**
     * List of icons for the exchanges
     * 
     * @param size The size of the icons. (required)
     * @return List&lt;V1Icon&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Icon> v1ExchangesIconsSizeGet(@javax.annotation.Nonnull Integer size) throws ApiException {
        ApiResponse<List<V1Icon>> localVarResp = v1ExchangesIconsSizeGetWithHttpInfo(size);
        return localVarResp.getData();
    }

    /**
     * List of icons for the exchanges
     * 
     * @param size The size of the icons. (required)
     * @return ApiResponse&lt;List&lt;V1Icon&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Icon>> v1ExchangesIconsSizeGetWithHttpInfo(@javax.annotation.Nonnull Integer size) throws ApiException {
        okhttp3.Call localVarCall = v1ExchangesIconsSizeGetValidateBeforeCall(size, null);
        Type localVarReturnType = new TypeToken<List<V1Icon>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List of icons for the exchanges (asynchronously)
     * 
     * @param size The size of the icons. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1ExchangesIconsSizeGetAsync(@javax.annotation.Nonnull Integer size, final ApiCallback<List<V1Icon>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1ExchangesIconsSizeGetValidateBeforeCall(size, _callback);
        Type localVarReturnType = new TypeToken<List<V1Icon>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1SymbolsExchangeIdGet
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @param filterSymbolId The filter for symbol ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1SymbolsExchangeIdGetCall(@javax.annotation.Nonnull String exchangeId, @javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterAssetId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/symbols/{exchange_id}"
            .replace("{" + "exchange_id" + "}", localVarApiClient.escapeString(exchangeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filterSymbolId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_symbol_id", filterSymbolId));
        }

        if (filterAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_asset_id", filterAssetId));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1SymbolsExchangeIdGetValidateBeforeCall(@javax.annotation.Nonnull String exchangeId, @javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterAssetId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exchangeId' is set
        if (exchangeId == null) {
            throw new ApiException("Missing the required parameter 'exchangeId' when calling v1SymbolsExchangeIdGet(Async)");
        }

        return v1SymbolsExchangeIdGetCall(exchangeId, filterSymbolId, filterAssetId, _callback);

    }

    /**
     * List of symbols for the exchange
     * 
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @param filterSymbolId The filter for symbol ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @return List&lt;V1Symbol&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Symbol> v1SymbolsExchangeIdGet(@javax.annotation.Nonnull String exchangeId, @javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterAssetId) throws ApiException {
        ApiResponse<List<V1Symbol>> localVarResp = v1SymbolsExchangeIdGetWithHttpInfo(exchangeId, filterSymbolId, filterAssetId);
        return localVarResp.getData();
    }

    /**
     * List of symbols for the exchange
     * 
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @param filterSymbolId The filter for symbol ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @return ApiResponse&lt;List&lt;V1Symbol&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Symbol>> v1SymbolsExchangeIdGetWithHttpInfo(@javax.annotation.Nonnull String exchangeId, @javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterAssetId) throws ApiException {
        okhttp3.Call localVarCall = v1SymbolsExchangeIdGetValidateBeforeCall(exchangeId, filterSymbolId, filterAssetId, null);
        Type localVarReturnType = new TypeToken<List<V1Symbol>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List of symbols for the exchange (asynchronously)
     * 
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @param filterSymbolId The filter for symbol ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1SymbolsExchangeIdGetAsync(@javax.annotation.Nonnull String exchangeId, @javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterAssetId, final ApiCallback<List<V1Symbol>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1SymbolsExchangeIdGetValidateBeforeCall(exchangeId, filterSymbolId, filterAssetId, _callback);
        Type localVarReturnType = new TypeToken<List<V1Symbol>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1SymbolsGet
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)
     * @param filterExchangeId The filter for exchange ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1SymbolsGetCall(@javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterExchangeId, @javax.annotation.Nullable String filterAssetId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/symbols";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filterSymbolId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_symbol_id", filterSymbolId));
        }

        if (filterExchangeId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_exchange_id", filterExchangeId));
        }

        if (filterAssetId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter_asset_id", filterAssetId));
        }

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1SymbolsGetValidateBeforeCall(@javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterExchangeId, @javax.annotation.Nullable String filterAssetId, final ApiCallback _callback) throws ApiException {
        return v1SymbolsGetCall(filterSymbolId, filterExchangeId, filterAssetId, _callback);

    }

    /**
     * List all symbols
     * Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  --------- | ---------  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  -------- | - | -----------  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  --------- | -----------  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  --------- | -----------  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  --------- | -----------  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  --------- | -----------  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  --------- | -----------  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)
     * @param filterExchangeId The filter for exchange ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @return List&lt;V1Symbol&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1Symbol> v1SymbolsGet(@javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterExchangeId, @javax.annotation.Nullable String filterAssetId) throws ApiException {
        ApiResponse<List<V1Symbol>> localVarResp = v1SymbolsGetWithHttpInfo(filterSymbolId, filterExchangeId, filterAssetId);
        return localVarResp.getData();
    }

    /**
     * List all symbols
     * Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  --------- | ---------  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  -------- | - | -----------  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  --------- | -----------  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  --------- | -----------  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  --------- | -----------  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  --------- | -----------  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  --------- | -----------  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)
     * @param filterExchangeId The filter for exchange ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @return ApiResponse&lt;List&lt;V1Symbol&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1Symbol>> v1SymbolsGetWithHttpInfo(@javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterExchangeId, @javax.annotation.Nullable String filterAssetId) throws ApiException {
        okhttp3.Call localVarCall = v1SymbolsGetValidateBeforeCall(filterSymbolId, filterExchangeId, filterAssetId, null);
        Type localVarReturnType = new TypeToken<List<V1Symbol>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List all symbols (asynchronously)
     * Retrieves all symbols with optional filtering.                :::info  \&quot;price_precision\&quot; and \&quot;size_precision\&quot; are data precisions and are not always the same precisions used for trading eg. for the \&quot;BINANCE\&quot; exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \&quot;price_precision\&quot; and \&quot;size_precision\&quot;. The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | &#x60;symbol_id&#x60; pattern  --------- | ---------  SPOT | &#x60;{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}&#x60;  FUTURES | &#x60;{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}&#x60;  OPTION | &#x60;{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}&#x60;  PERPETUAL | &#x60;{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}&#x60;  INDEX | &#x60;{exchange_id}_IDX_{index_id}&#x60;  CREDIT | &#x60;{exchange_id}_CRE_{asset_id_base}&#x60;  CONTACT  | &#x60;{exchange_id}_COT_{contract_id}&#x60;                :::info  In the unlikely event when the \&quot;symbol_id\&quot; for more than one market is the same. We will append the additional term (prefixed with the \&quot;_\&quot;) at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of &#x60;symbol_type&#x60; output variable)                Type | Name | Description  -------- | - | -----------  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for &#x60;symbol_type &#x3D; INDEX&#x60;                Variable | Description  --------- | -----------  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for &#x60;symbol_type &#x3D; FUTURES&#x60;                Variable | Description  --------- | -----------  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; PERPETUAL&#x60;                Variable | Description  --------- | -----------  future_contract_unit | Contact size *(eg. 10 BTC if &#x60;future_contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;future_contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for &#x60;symbol_type &#x3D; OPTION&#x60;                Variable | Description  --------- | -----------  option_type_is_call | Boolean value representing option type. &#x60;true&#x60; for Call options, &#x60;false&#x60; for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be &#x60;EUROPEAN&#x60; or &#x60;AMERICAN&#x60;  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for &#x60;symbol_type &#x3D; CONTRACT&#x60;                Variable | Description  --------- | -----------  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if &#x60;contract_unit&#x60; &#x3D; &#x60;10&#x60; and &#x60;contract_unit_asset&#x60; &#x3D; &#x60;BTC&#x60;)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
     * @param filterSymbolId Comma or semicolon delimited parts of symbol identifier used to filter response. (optional, eg. &#x60;BITSTAMP&#x60;_ or &#x60;BINANCE_SPOT_&#x60;) (optional)
     * @param filterExchangeId The filter for exchange ID. (optional)
     * @param filterAssetId The filter for asset ID. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1SymbolsGetAsync(@javax.annotation.Nullable String filterSymbolId, @javax.annotation.Nullable String filterExchangeId, @javax.annotation.Nullable String filterAssetId, final ApiCallback<List<V1Symbol>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1SymbolsGetValidateBeforeCall(filterSymbolId, filterExchangeId, filterAssetId, _callback);
        Type localVarReturnType = new TypeToken<List<V1Symbol>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for v1SymbolsMapExchangeIdGet
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1SymbolsMapExchangeIdGetCall(@javax.annotation.Nonnull String exchangeId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/symbols/map/{exchange_id}"
            .replace("{" + "exchange_id" + "}", localVarApiClient.escapeString(exchangeId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/plain",
            "application/json",
            "text/json",
            "application/x-msgpack"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "ApiKey" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call v1SymbolsMapExchangeIdGetValidateBeforeCall(@javax.annotation.Nonnull String exchangeId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'exchangeId' is set
        if (exchangeId == null) {
            throw new ApiException("Missing the required parameter 'exchangeId' when calling v1SymbolsMapExchangeIdGet(Async)");
        }

        return v1SymbolsMapExchangeIdGetCall(exchangeId, _callback);

    }

    /**
     * List symbol mapping for the exchange
     * 
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @return List&lt;V1SymbolMapping&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public List<V1SymbolMapping> v1SymbolsMapExchangeIdGet(@javax.annotation.Nonnull String exchangeId) throws ApiException {
        ApiResponse<List<V1SymbolMapping>> localVarResp = v1SymbolsMapExchangeIdGetWithHttpInfo(exchangeId);
        return localVarResp.getData();
    }

    /**
     * List symbol mapping for the exchange
     * 
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @return ApiResponse&lt;List&lt;V1SymbolMapping&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<V1SymbolMapping>> v1SymbolsMapExchangeIdGetWithHttpInfo(@javax.annotation.Nonnull String exchangeId) throws ApiException {
        okhttp3.Call localVarCall = v1SymbolsMapExchangeIdGetValidateBeforeCall(exchangeId, null);
        Type localVarReturnType = new TypeToken<List<V1SymbolMapping>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List symbol mapping for the exchange (asynchronously)
     * 
     * @param exchangeId The ID of the exchange (from the Metadata -&gt; Exchanges) (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> successful operation </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call v1SymbolsMapExchangeIdGetAsync(@javax.annotation.Nonnull String exchangeId, final ApiCallback<List<V1SymbolMapping>> _callback) throws ApiException {

        okhttp3.Call localVarCall = v1SymbolsMapExchangeIdGetValidateBeforeCall(exchangeId, _callback);
        Type localVarReturnType = new TypeToken<List<V1SymbolMapping>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
