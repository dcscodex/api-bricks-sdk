// @flow
/* eslint-disable no-use-before-define */
/**
 * REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://rest.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Represents a timeseries item with price and volume information.
 * @export
 */
export type ModelsExchangeTimeseriesItem = {
    /**
     * The start time of the time period.
     * @type {Date}
     * @memberof ModelsExchangeTimeseriesItem
     */
    time_period_start?: Date;
    /**
     * The end time of the time period.
     * @type {Date}
     * @memberof ModelsExchangeTimeseriesItem
     */
    time_period_end?: Date;
    /**
     * The time when the price opened.
     * @type {Date}
     * @memberof ModelsExchangeTimeseriesItem
     */
    time_open?: Date;
    /**
     * The time when the price closed.
     * @type {Date}
     * @memberof ModelsExchangeTimeseriesItem
     */
    time_close?: Date;
    /**
     * The opening price.
     * @type {number}
     * @memberof ModelsExchangeTimeseriesItem
     */
    price_open?: number;
    /**
     * The highest price during the time period.
     * @type {number}
     * @memberof ModelsExchangeTimeseriesItem
     */
    price_high?: number;
    /**
     * The lowest price during the time period.
     * @type {number}
     * @memberof ModelsExchangeTimeseriesItem
     */
    price_low?: number;
    /**
     * The closing price.
     * @type {number}
     * @memberof ModelsExchangeTimeseriesItem
     */
    price_close?: number;
    /**
     * The total volume traded during the time period.
     * @type {number}
     * @memberof ModelsExchangeTimeseriesItem
     */
    volume_traded?: number;
    /**
     * The number of trades executed during the time period.
     * @type {number}
     * @memberof ModelsExchangeTimeseriesItem
     */
    trades_count?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsExchangeTimeseriesItem
     */
    symbol_id_exchange?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsExchangeTimeseriesItem
     */
    symbol_id_coinapi?: string;
}

/**
 * Represents an option exchange group data model.
 * @export
 */
export type OptionsOptionExchangeGroup = {
    /**
     * The base asset identifier.
     * @type {string}
     * @memberof OptionsOptionExchangeGroup
     */
    asset_id_base?: string;
    /**
     * The quote asset identifier.
     * @type {string}
     * @memberof OptionsOptionExchangeGroup
     */
    asset_id_quote?: string;
    /**
     * The underlying price of the option.
     * @type {number}
     * @memberof OptionsOptionExchangeGroup
     */
    underlying_price?: number;
    /**
     * The expiration time of the option.
     * @type {Date}
     * @memberof OptionsOptionExchangeGroup
     */
    time_expiration?: Date;
    /**
     * The list of strikes available.
     * @type {Array<OptionsStrike>}
     * @memberof OptionsOptionExchangeGroup
     */
    strikes?: Array<OptionsStrike>;
}

/**
 * Represents a strike within the option exchange group.
 * @export
 */
export type OptionsStrike = {
    /**
     * The strike price.
     * @type {number}
     * @memberof OptionsStrike
     */
    strike_price?: number;
    /**
     * 
     * @type {V1QuoteTrade}
     * @memberof OptionsStrike
     */
    call?: V1QuoteTrade;
    /**
     * 
     * @type {V1QuoteTrade}
     * @memberof OptionsStrike
     */
    put?: V1QuoteTrade;
}

/**
 * Represents an asset.
 * @export
 */
export type V1Asset = {
    /**
     * Gets or sets the asset ID.
     * @type {string}
     * @memberof V1Asset
     */
    asset_id?: string;
    /**
     * Gets or sets the name of the asset.
     * @type {string}
     * @memberof V1Asset
     */
    name?: string;
    /**
     * Gets or sets a value indicating whether the asset is a cryptocurrency.
     * @type {number}
     * @memberof V1Asset
     */
    type_is_crypto?: number;
    /**
     * Gets or sets the start date of quote data.
     * @type {Date}
     * @memberof V1Asset
     */
    data_quote_start?: Date;
    /**
     * Gets or sets the end date of quote data.
     * @type {Date}
     * @memberof V1Asset
     */
    data_quote_end?: Date;
    /**
     * Gets or sets the start date of order book data.
     * @type {Date}
     * @memberof V1Asset
     */
    data_orderbook_start?: Date;
    /**
     * Gets or sets the end date of order book data.
     * @type {Date}
     * @memberof V1Asset
     */
    data_orderbook_end?: Date;
    /**
     * Gets or sets the start date of trade data.
     * @type {Date}
     * @memberof V1Asset
     */
    data_trade_start?: Date;
    /**
     * Gets or sets the end date of trade data.
     * @type {Date}
     * @memberof V1Asset
     */
    data_trade_end?: Date;
    /**
     * Gets or sets the number of symbols.
     * @type {number}
     * @memberof V1Asset
     */
    data_symbols_count?: number;
    /**
     * Gets or sets the USD volume in the last 1 hour.
     * @type {number}
     * @memberof V1Asset
     */
    volume_1hrs_usd?: number;
    /**
     * Gets or sets the USD volume in the last 1 day.
     * @type {number}
     * @memberof V1Asset
     */
    volume_1day_usd?: number;
    /**
     * Gets or sets the USD volume in the last 1 month.
     * @type {number}
     * @memberof V1Asset
     */
    volume_1mth_usd?: number;
    /**
     * Gets or sets the USD price of the asset.
     * @type {number}
     * @memberof V1Asset
     */
    price_usd?: number;
    /**
     * Gets or sets the ID of the icon for the asset.
     * @type {string}
     * @memberof V1Asset
     */
    id_icon?: string;
    /**
     * Gets or sets the current supply of the asset.
     * @type {number}
     * @memberof V1Asset
     */
    supply_current?: number;
    /**
     * Gets or sets the total supply of the asset.
     * @type {number}
     * @memberof V1Asset
     */
    supply_total?: number;
    /**
     * Gets or sets the maximum supply of the asset.
     * @type {number}
     * @memberof V1Asset
     */
    supply_max?: number;
    /**
     * 
     * @type {Array<V1ChainNetworkAddress>}
     * @memberof V1Asset
     */
    chain_addresses?: Array<V1ChainNetworkAddress>;
    /**
     * 
     * @type {string}
     * @memberof V1Asset
     */
    data_start?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Asset
     */
    data_end?: string;
}

/**
 * Represents a blockchain chain.
 * @export
 */
export type V1Chain = {
    /**
     * Gets or sets the chain identifier.
     * @type {string}
     * @memberof V1Chain
     */
    chain_id?: string;
    /**
     * Gets or sets the name of the chain.
     * @type {string}
     * @memberof V1Chain
     */
    name?: string;
}

/**
 * Contains information about assets\' chain network addresses
 * @export
 */
export type V1ChainNetworkAddress = {
    /**
     * Gets or sets chain id
     * @type {string}
     * @memberof V1ChainNetworkAddress
     */
    chain_id?: string;
    /**
     * Gets or sets network id
     * @type {string}
     * @memberof V1ChainNetworkAddress
     */
    network_id?: string;
    /**
     * Gets or sets chain address
     * @type {string}
     * @memberof V1ChainNetworkAddress
     */
    address?: string;
}

/**
 * Represents an exchange.
 * @export
 */
export type V1Exchange = {
    /**
     * Gets or sets the exchange ID.
     * @type {string}
     * @memberof V1Exchange
     */
    exchange_id?: string;
    /**
     * Gets or sets the website URL of the exchange.
     * @type {string}
     * @memberof V1Exchange
     */
    website?: string;
    /**
     * Gets or sets the name of the exchange.
     * @type {string}
     * @memberof V1Exchange
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Exchange
     */
    data_start?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Exchange
     */
    data_end?: string;
    /**
     * Gets or sets the start date of quote data.
     * @type {Date}
     * @memberof V1Exchange
     */
    data_quote_start?: Date;
    /**
     * Gets or sets the end date of quote data.
     * @type {Date}
     * @memberof V1Exchange
     */
    data_quote_end?: Date;
    /**
     * Gets or sets the start date of order book data.
     * @type {Date}
     * @memberof V1Exchange
     */
    data_orderbook_start?: Date;
    /**
     * Gets or sets the end date of order book data.
     * @type {Date}
     * @memberof V1Exchange
     */
    data_orderbook_end?: Date;
    /**
     * Gets or sets the start date of trade data.
     * @type {Date}
     * @memberof V1Exchange
     */
    data_trade_start?: Date;
    /**
     * Gets or sets the end date of trade data.
     * @type {Date}
     * @memberof V1Exchange
     */
    data_trade_end?: Date;
    /**
     * Gets or sets the number of trades.
     * @type {number}
     * @memberof V1Exchange
     */
    data_trade_count?: number;
    /**
     * Gets or sets the number of symbols.
     * @type {number}
     * @memberof V1Exchange
     */
    data_symbols_count?: number;
    /**
     * Gets or sets the USD volume in the last 1 hour.
     * @type {number}
     * @memberof V1Exchange
     */
    volume_1hrs_usd?: number;
    /**
     * Gets or sets the USD volume in the last 1 day.
     * @type {number}
     * @memberof V1Exchange
     */
    volume_1day_usd?: number;
    /**
     * Gets or sets the USD volume in the last 1 month.
     * @type {number}
     * @memberof V1Exchange
     */
    volume_1mth_usd?: number;
    /**
     * Gets or sets the list of metric IDs.
     * @type {Array<string>}
     * @memberof V1Exchange
     */
    metric_id?: Array<string>;
    /**
     * Gets or sets the list of icons for the exchange.
     * @type {Array<V1Icon>}
     * @memberof V1Exchange
     */
    icons?: Array<V1Icon>;
    /**
     * Rank of the exchange.
     * @type {number}
     * @memberof V1Exchange
     */
    rank?: number;
    /**
     * Status of the integration
     * @type {string}
     * @memberof V1Exchange
     */
    integration_status?: string;
}

/**
 * Represents an exchange rate.
 * @export
 */
export type V1ExchangeRate = {
    /**
     * Gets or sets the time of the exchange rate.
     * @type {Date}
     * @memberof V1ExchangeRate
     */
    time?: Date;
    /**
     * Gets or sets the base asset ID of the exchange rate.
     * @type {string}
     * @memberof V1ExchangeRate
     */
    asset_id_base?: string;
    /**
     * Gets or sets the quote asset ID of the exchange rate.
     * @type {string}
     * @memberof V1ExchangeRate
     */
    asset_id_quote?: string;
    /**
     * Gets or sets the exchange rate value.
     * @type {number}
     * @memberof V1ExchangeRate
     */
    rate?: number;
}

/**
 * Represents exchange rates for a specific base asset.
 * @export
 */
export type V1ExchangeRates = {
    /**
     * Gets or sets the base asset ID.
     * @type {string}
     * @memberof V1ExchangeRates
     */
    asset_id_base?: string;
    /**
     * Gets or sets the list of exchange rates.
     * @type {Array<V1ExchangeRatesRate>}
     * @memberof V1ExchangeRates
     */
    rates?: Array<V1ExchangeRatesRate>;
}

/**
 * Represents an exchange rate within a collection of exchange rates.
 * @export
 */
export type V1ExchangeRatesRate = {
    /**
     * Gets or sets the time of the exchange rate.
     * @type {Date}
     * @memberof V1ExchangeRatesRate
     */
    time?: Date;
    /**
     * Gets or sets the quote asset ID of the exchange rate.
     * @type {string}
     * @memberof V1ExchangeRatesRate
     */
    asset_id_quote?: string;
    /**
     * Gets or sets the exchange rate value.
     * @type {number}
     * @memberof V1ExchangeRatesRate
     */
    rate?: number;
}

/**
 * Represents an item in the exchange rate timeseries.
 * @export
 */
export type V1ExchangeRatesTimeseriesItem = {
    /**
     * Gets or sets the start time of the period.
     * @type {Date}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    time_period_start?: Date;
    /**
     * Gets or sets the end time of the period.
     * @type {Date}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    time_period_end?: Date;
    /**
     * Gets or sets the opening time of the period.
     * @type {Date}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    time_open?: Date;
    /**
     * Gets or sets the closing time of the period.
     * @type {Date}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    time_close?: Date;
    /**
     * Gets or sets the opening rate for the period.
     * @type {number}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    rate_open?: number;
    /**
     * Gets or sets the highest rate for the period.
     * @type {number}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    rate_high?: number;
    /**
     * Gets or sets the lowest rate for the period.
     * @type {number}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    rate_low?: number;
    /**
     * Gets or sets the closing rate for the period.
     * @type {number}
     * @memberof V1ExchangeRatesTimeseriesItem
     */
    rate_close?: number;
}

/**
 * Represents an external asset with description.
 * @export
 */
export type V1ExternalAsset = {
    /**
     * Gets or sets the asset identifier.
     * @type {string}
     * @memberof V1ExternalAsset
     */
    asset_id?: string;
    /**
     * Gets or sets the description of the asset.
     * @type {string}
     * @memberof V1ExternalAsset
     */
    description?: string;
    /**
     * Gets or sets the type/category of the asset.
     * @type {string}
     * @memberof V1ExternalAsset
     */
    asset_type?: string;
}

/**
 * Represents an exchange with external mapping for metrics.
 * @export
 */
export type V1ExternalExchange = {
    /**
     * Gets or sets the internal exchange identifier.
     * @type {string}
     * @memberof V1ExternalExchange
     */
    exchange_id?: string;
    /**
     * Gets or sets the external protocol name/slug.
     * @type {string}
     * @memberof V1ExternalExchange
     */
    external_name?: string;
    /**
     * Gets or sets the description of the exchange.
     * @type {string}
     * @memberof V1ExternalExchange
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ExternalExchange
     */
    source_id?: string;
}

/**
 * Class representation of general metric data. This class is an XML type with name \'general_data\' and inherits from the BaseCsvModel class.
 * @export
 */
export type V1GeneralData = {
    /**
     * Gets or sets the entry time for the data point.
     * @type {Date}
     * @memberof V1GeneralData
     */
    entry_time?: Date;
    /**
     * Gets or sets the received time for the data point.
     * @type {Date}
     * @memberof V1GeneralData
     */
    recv_time?: Date;
    /**
     * Gets or sets the identifier for the exchange.
     * @type {string}
     * @memberof V1GeneralData
     */
    exchange_id?: string;
    /**
     * Gets or sets the identifier for the asset.
     * @type {string}
     * @memberof V1GeneralData
     */
    asset_id?: string;
    /**
     * Gets or sets the identifier for the symbol.
     * @type {string}
     * @memberof V1GeneralData
     */
    symbol_id?: string;
    /**
     * Gets or sets the identifier for the metric.
     * @type {string}
     * @memberof V1GeneralData
     */
    metric_id?: string;
    /**
     * Gets or sets the decimal value for the metric.
     * @type {number}
     * @memberof V1GeneralData
     */
    value_decimal?: number;
    /**
     * Gets or sets the textual representation of the value for the metric.
     * @type {string}
     * @memberof V1GeneralData
     */
    value_text?: string;
    /**
     * Gets or sets the timestamp value for the metric.
     * @type {Date}
     * @memberof V1GeneralData
     */
    value_time?: Date;
}

/**
 * Represents an icon.
 * @export
 */
export type V1Icon = {
    /**
     * Gets or sets the exchange ID associated with the icon.
     * @type {string}
     * @memberof V1Icon
     */
    exchange_id?: string;
    /**
     * Gets or sets the asset ID associated with the icon.
     * @type {string}
     * @memberof V1Icon
     */
    asset_id?: string;
    /**
     * Gets or sets the URL of the icon.
     * @type {string}
     * @memberof V1Icon
     */
    url?: string;
}

/**
 * Represents the last executed transaction.
 * @export
 */
export type V1LastTrade = {
    /**
     * The exchange time of the last trade.
     * @type {Date}
     * @memberof V1LastTrade
     */
    time_exchange?: Date;
    /**
     * The CoinAPI time when the last trade was received.
     * @type {Date}
     * @memberof V1LastTrade
     */
    time_coinapi?: Date;
    /**
     * The UUID of the last trade.
     * @type {string}
     * @memberof V1LastTrade
     */
    uuid?: string;
    /**
     * The price of the last trade.
     * @type {number}
     * @memberof V1LastTrade
     */
    price?: number;
    /**
     * The size of the last trade.
     * @type {number}
     * @memberof V1LastTrade
     */
    size?: number;
    /**
     * The taker side of the last trade.
     * @type {string}
     * @memberof V1LastTrade
     */
    taker_side?: string;
}

/**
 * Represents a listing item.
 * @export
 */
export type V1ListingItem = {
    /**
     * Gets or sets the metric ID.
     * @type {string}
     * @memberof V1ListingItem
     */
    metric_id?: string;
    /**
     * Gets or sets the symbol ID.
     * @type {string}
     * @memberof V1ListingItem
     */
    symbol_id?: string;
    /**
     * Gets or sets the symbol ID from the exchange.
     * @type {string}
     * @memberof V1ListingItem
     */
    symbol_id_external?: string;
    /**
     * Gets or sets the exchange ID.
     * @type {string}
     * @memberof V1ListingItem
     */
    exchange_id?: string;
    /**
     * Gets or sets the asset ID.
     * @type {string}
     * @memberof V1ListingItem
     */
    asset_id?: string;
    /**
     * Gets or sets the asset ID from the exchange.
     * @type {string}
     * @memberof V1ListingItem
     */
    asset_id_external?: string;
    /**
     * Gets or sets the chain id.
     * @type {string}
     * @memberof V1ListingItem
     */
    chain_id?: string;
    /**
     * Gets or sets the network id.
     * @type {string}
     * @memberof V1ListingItem
     */
    network_id?: string;
}

/**
 * Represents a metric.
 * @export
 */
export type V1Metric = {
    /**
     * Gets or sets the metric ID.
     * @type {string}
     * @memberof V1Metric
     */
    metric_id?: string;
    /**
     * Gets or sets the metric description.
     * @type {string}
     * @memberof V1Metric
     */
    description?: string;
}

/**
 * Represents a data model for metric data.
 * @export
 */
export type V1MetricData = {
    /**
     * Gets or sets the symbol id.
     * @type {string}
     * @memberof V1MetricData
     */
    symbol_id?: string;
    /**
     * Gets or sets the time at which the value is recorded.
     * @type {Date}
     * @memberof V1MetricData
     */
    time?: Date;
    /**
     * Gets or sets the value of the metric.
     * @type {number}
     * @memberof V1MetricData
     */
    value?: number;
}

/**
 * Represents a metric information.
 * @export
 */
export type V1MetricInfo = {
    /**
     * Gets or sets the metric identifier.
     * @type {string}
     * @memberof V1MetricInfo
     */
    metric_id?: string;
    /**
     * Gets or sets the description of the metric.
     * @type {string}
     * @memberof V1MetricInfo
     */
    description?: string;
    /**
     * Gets or sets the source identifier of the metric.
     * @type {string}
     * @memberof V1MetricInfo
     */
    source_id?: string;
}

/**
 * Represents an order book with additional information and functionality.
 * @export
 */
export type V1OrderBook = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1OrderBook
     */
    symbol_id?: string;
    /**
     * The exchange time of the order book.
     * @type {Date}
     * @memberof V1OrderBook
     */
    time_exchange?: Date;
    /**
     * The CoinAPI time when the order book was received.
     * @type {Date}
     * @memberof V1OrderBook
     */
    time_coinapi?: Date;
    /**
     * The asks made by market makers.
     * @type {AnyType}
     * @memberof V1OrderBook
     */
    asks?: AnyType;
    /**
     * The bids made by market makers.
     * @type {AnyType}
     * @memberof V1OrderBook
     */
    bids?: AnyType;
}

/**
 * Represents the base model for order book data.
 * @export
 */
export type V1OrderBookBase = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1OrderBookBase
     */
    symbol_id?: string;
    /**
     * The exchange time of the order book.
     * @type {Date}
     * @memberof V1OrderBookBase
     */
    time_exchange?: Date;
    /**
     * The CoinAPI time when the order book was received.
     * @type {Date}
     * @memberof V1OrderBookBase
     */
    time_coinapi?: Date;
    /**
     * The asks made by market makers.
     * @type {AnyType}
     * @memberof V1OrderBookBase
     */
    asks?: AnyType;
    /**
     * The bids made by market makers.
     * @type {AnyType}
     * @memberof V1OrderBookBase
     */
    bids?: AnyType;
}

/**
 * Represents the depth of an order book.
 * @export
 */
export type V1OrderBookDepth = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1OrderBookDepth
     */
    symbol_id?: string;
    /**
     * The exchange time of the order book.
     * @type {Date}
     * @memberof V1OrderBookDepth
     */
    time_exchange?: Date;
    /**
     * The CoinAPI time when the order book was received.
     * @type {Date}
     * @memberof V1OrderBookDepth
     */
    time_coinapi?: Date;
    /**
     * The number of ask levels in the order book.
     * @type {number}
     * @memberof V1OrderBookDepth
     */
    ask_levels?: number;
    /**
     * The number of bid levels in the order book.
     * @type {number}
     * @memberof V1OrderBookDepth
     */
    bid_levels?: number;
    /**
     * The depth of the ask side of the order book.
     * @type {number}
     * @memberof V1OrderBookDepth
     */
    ask_depth?: number;
    /**
     * The depth of the bid side of the order book.
     * @type {number}
     * @memberof V1OrderBookDepth
     */
    bid_depth?: number;
}

/**
 * Represents a quote data model.
 * @export
 */
export type V1Quote = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1Quote
     */
    symbol_id?: string;
    /**
     * The exchange time of the quote.
     * @type {Date}
     * @memberof V1Quote
     */
    time_exchange?: Date;
    /**
     * The CoinAPI time when the quote was received.
     * @type {Date}
     * @memberof V1Quote
     */
    time_coinapi?: Date;
    /**
     * The best asking price.
     * @type {number}
     * @memberof V1Quote
     */
    ask_price?: number;
    /**
     * The volume resting on the best ask. If the value is equal to zero, then the size is unknown.
     * @type {number}
     * @memberof V1Quote
     */
    ask_size?: number;
    /**
     * The best bidding price.
     * @type {number}
     * @memberof V1Quote
     */
    bid_price?: number;
    /**
     * The volume resting on the best bid. If the value is equal to zero, then the size is unknown.
     * @type {number}
     * @memberof V1Quote
     */
    bid_size?: number;
}

/**
 * Represents a quote trade data model.
 * @export
 */
export type V1QuoteTrade = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1QuoteTrade
     */
    symbol_id?: string;
    /**
     * The exchange time of the quote trade.
     * @type {Date}
     * @memberof V1QuoteTrade
     */
    time_exchange?: Date;
    /**
     * The CoinAPI time when the quote trade was received.
     * @type {Date}
     * @memberof V1QuoteTrade
     */
    time_coinapi?: Date;
    /**
     * The best asking price.
     * @type {number}
     * @memberof V1QuoteTrade
     */
    ask_price?: number;
    /**
     * The volume resting on the best ask. If the value is equal to zero, then the size is unknown.
     * @type {number}
     * @memberof V1QuoteTrade
     */
    ask_size?: number;
    /**
     * The best bidding price.
     * @type {number}
     * @memberof V1QuoteTrade
     */
    bid_price?: number;
    /**
     * The volume resting on the best bid. If the value is equal to zero, then the size is unknown.
     * @type {number}
     * @memberof V1QuoteTrade
     */
    bid_size?: number;
    /**
     * 
     * @type {V1LastTrade}
     * @memberof V1QuoteTrade
     */
    last_trade?: V1LastTrade;
}

/**
 * Represents a symbol data model.
 * @export
 */
export type V1Symbol = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    symbol_id?: string;
    /**
     * The exchange identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    exchange_id?: string;
    /**
     * The symbol type.
     * @type {string}
     * @memberof V1Symbol
     */
    symbol_type?: string;
    /**
     * The base asset identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    asset_id_base?: string;
    /**
     * The quote asset identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    asset_id_quote?: string;
    /**
     * The unit asset identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    asset_id_unit?: string;
    /**
     * The contract unit for futures.
     * @type {number}
     * @memberof V1Symbol
     */
    future_contract_unit?: number;
    /**
     * The asset used as the unit for futures contract.
     * @type {string}
     * @memberof V1Symbol
     */
    future_contract_unit_asset?: string;
    /**
     * The future delivery time for futures contract.
     * @type {Date}
     * @memberof V1Symbol
     */
    future_delivery_time?: Date;
    /**
     * Indicates whether the option type is a call.
     * @type {boolean}
     * @memberof V1Symbol
     */
    option_type_is_call?: boolean;
    /**
     * The strike price for options.
     * @type {number}
     * @memberof V1Symbol
     */
    option_strike_price?: number;
    /**
     * The contract unit for options.
     * @type {number}
     * @memberof V1Symbol
     */
    option_contract_unit?: number;
    /**
     * The exercise style for options.
     * @type {string}
     * @memberof V1Symbol
     */
    option_exercise_style?: string;
    /**
     * The expiration time for options.
     * @type {Date}
     * @memberof V1Symbol
     */
    option_expiration_time?: Date;
    /**
     * The delivery time for contracts.
     * @type {Date}
     * @memberof V1Symbol
     */
    contract_delivery_time?: Date;
    /**
     * The contract unit for contracts.
     * @type {number}
     * @memberof V1Symbol
     */
    contract_unit?: number;
    /**
     * The asset used as the unit for contracts.
     * @type {string}
     * @memberof V1Symbol
     */
    contract_unit_asset?: string;
    /**
     * The contract identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    contract_id?: string;
    /**
     * The display name of the contract.
     * @type {string}
     * @memberof V1Symbol
     */
    contract_display_name?: string;
    /**
     * The display description of the contract.
     * @type {string}
     * @memberof V1Symbol
     */
    contract_display_description?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Symbol
     */
    data_start?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Symbol
     */
    data_end?: string;
    /**
     * The start date of quote data.
     * @type {Date}
     * @memberof V1Symbol
     */
    data_quote_start?: Date;
    /**
     * The end date of quote data.
     * @type {Date}
     * @memberof V1Symbol
     */
    data_quote_end?: Date;
    /**
     * The start date of order book data.
     * @type {Date}
     * @memberof V1Symbol
     */
    data_orderbook_start?: Date;
    /**
     * The end date of order book data.
     * @type {Date}
     * @memberof V1Symbol
     */
    data_orderbook_end?: Date;
    /**
     * The start date of trade data.
     * @type {Date}
     * @memberof V1Symbol
     */
    data_trade_start?: Date;
    /**
     * The end date of trade data.
     * @type {Date}
     * @memberof V1Symbol
     */
    data_trade_end?: Date;
    /**
     * The index identifier.
     * @type {string}
     * @memberof V1Symbol
     */
    index_id?: string;
    /**
     * The display name of the index.
     * @type {string}
     * @memberof V1Symbol
     */
    index_display_name?: string;
    /**
     * The display description of the index.
     * @type {string}
     * @memberof V1Symbol
     */
    index_display_description?: string;
    /**
     * The volume in the last 1 hour.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_1hrs?: number;
    /**
     * The volume in USD in the last 1 hour.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_1hrs_usd?: number;
    /**
     * The volume in the last 1 day.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_1day?: number;
    /**
     * The volume in USD in the last 1 day.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_1day_usd?: number;
    /**
     * The volume in the last 1 month.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_1mth?: number;
    /**
     * The volume in USD in the last 1 month.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_1mth_usd?: number;
    /**
     * The price.
     * @type {number}
     * @memberof V1Symbol
     */
    price?: number;
    /**
     * The symbol identifier in the exchange.
     * @type {string}
     * @memberof V1Symbol
     */
    symbol_id_exchange?: string;
    /**
     * The base asset identifier in the exchange.
     * @type {string}
     * @memberof V1Symbol
     */
    asset_id_base_exchange?: string;
    /**
     * The quote asset identifier in the exchange.
     * @type {string}
     * @memberof V1Symbol
     */
    asset_id_quote_exchange?: string;
    /**
     * The price precision.
     * @type {number}
     * @memberof V1Symbol
     */
    price_precision?: number;
    /**
     * The size precision.
     * @type {number}
     * @memberof V1Symbol
     */
    size_precision?: number;
    /**
     * Not normalized raw kvp data.
     * @type {{ [key: string]: string; }}
     * @memberof V1Symbol
     */
    raw_kvp?: { [key: string]: string; };
    /**
     * Volume unit in USD.
     * @type {number}
     * @memberof V1Symbol
     */
    volume_to_usd?: number;
}

/**
 * Represents symbol mapping information for exchange symbols.
 * @export
 */
export type V1SymbolMapping = {
    /**
     * The symbol ID.
     * @type {string}
     * @memberof V1SymbolMapping
     */
    symbol_id?: string;
    /**
     * The exchange-specific symbol ID.
     * @type {string}
     * @memberof V1SymbolMapping
     */
    symbol_id_exchange?: string;
    /**
     * The CoinAPI DataInfo ID.
     * @type {number}
     * @memberof V1SymbolMapping
     */
    coinapi_datainfo_id?: number;
    /**
     * The exchange-specific base asset ID.
     * @type {string}
     * @memberof V1SymbolMapping
     */
    asset_id_base_exchange?: string;
    /**
     * The exchange-specific quote asset ID.
     * @type {string}
     * @memberof V1SymbolMapping
     */
    asset_id_quote_exchange?: string;
    /**
     * The base asset ID.
     * @type {string}
     * @memberof V1SymbolMapping
     */
    asset_id_base?: string;
    /**
     * The quote asset ID.
     * @type {string}
     * @memberof V1SymbolMapping
     */
    asset_id_quote?: string;
    /**
     * The price precision.
     * @type {number}
     * @memberof V1SymbolMapping
     */
    price_precision?: number;
    /**
     * The size precision.
     * @type {number}
     * @memberof V1SymbolMapping
     */
    size_precision?: number;
}

/**
 * Represents a timeseries item with price and volume information.
 * @export
 */
export type V1TimeseriesItem = {
    /**
     * The start time of the time period.
     * @type {Date}
     * @memberof V1TimeseriesItem
     */
    time_period_start?: Date;
    /**
     * The end time of the time period.
     * @type {Date}
     * @memberof V1TimeseriesItem
     */
    time_period_end?: Date;
    /**
     * The time when the price opened.
     * @type {Date}
     * @memberof V1TimeseriesItem
     */
    time_open?: Date;
    /**
     * The time when the price closed.
     * @type {Date}
     * @memberof V1TimeseriesItem
     */
    time_close?: Date;
    /**
     * The opening price.
     * @type {number}
     * @memberof V1TimeseriesItem
     */
    price_open?: number;
    /**
     * The highest price during the time period.
     * @type {number}
     * @memberof V1TimeseriesItem
     */
    price_high?: number;
    /**
     * The lowest price during the time period.
     * @type {number}
     * @memberof V1TimeseriesItem
     */
    price_low?: number;
    /**
     * The closing price.
     * @type {number}
     * @memberof V1TimeseriesItem
     */
    price_close?: number;
    /**
     * The total volume traded during the time period.
     * @type {number}
     * @memberof V1TimeseriesItem
     */
    volume_traded?: number;
    /**
     * The number of trades executed during the time period.
     * @type {number}
     * @memberof V1TimeseriesItem
     */
    trades_count?: number;
}

/**
 * Represents a timeseries period used in exchange rate data.
 * @export
 */
export type V1TimeseriesPeriod = {
    /**
     * The period ID.
     * @type {string}
     * @memberof V1TimeseriesPeriod
     */
    period_id?: string;
    /**
     * The length of the period in seconds.
     * @type {number}
     * @memberof V1TimeseriesPeriod
     */
    length_seconds?: number;
    /**
     * The length of the period in months.
     * @type {number}
     * @memberof V1TimeseriesPeriod
     */
    length_months?: number;
    /**
     * The unit count.
     * @type {number}
     * @memberof V1TimeseriesPeriod
     */
    unit_count?: number;
    /**
     * The unit name.
     * @type {string}
     * @memberof V1TimeseriesPeriod
     */
    unit_name?: string;
    /**
     * The display name of the timeseries period.
     * @type {string}
     * @memberof V1TimeseriesPeriod
     */
    display_name?: string;
}

/**
 * Represents a trade executed on the exchange.
 * @export
 */
export type V1Trade = {
    /**
     * The symbol identifier.
     * @type {string}
     * @memberof V1Trade
     */
    symbol_id?: string;
    /**
     * The time of trade reported by the exchange.
     * @type {Date}
     * @memberof V1Trade
     */
    time_exchange?: Date;
    /**
     * The time when the trade was received by CoinAPI.
     * @type {Date}
     * @memberof V1Trade
     */
    time_coinapi?: Date;
    /**
     * The unique identifier for the trade.
     * @type {string}
     * @memberof V1Trade
     */
    uuid?: string;
    /**
     * The price of the transaction.
     * @type {number}
     * @memberof V1Trade
     */
    price?: number;
    /**
     * The base asset amount traded in the transaction.
     * @type {number}
     * @memberof V1Trade
     */
    size?: number;
    /**
     * The aggressor side of the transaction (BUY/SELL/BUY_ESTIMATED/SELL_ESTIMATED/UNKNOWN).
     * @type {string}
     * @memberof V1Trade
     */
    taker_side?: string;
    /**
     * The trade identifier.
     * @type {string}
     * @memberof V1Trade
     */
    id_trade?: string;
    /**
     * The order maker identifier.
     * @type {string}
     * @memberof V1Trade
     */
    id_order_maker?: string;
    /**
     * The order taker identifier.
     * @type {string}
     * @memberof V1Trade
     */
    id_order_taker?: string;
}



/**
 * ExchangeRatesApi - fetch parameter creator
 * @export
 */
export const ExchangeRatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.                :::info  If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements.  :::
         * @summary Get specific rate
         * @throws {RequiredError}
         */
        getSpecificRate(assetIdBase: string, assetIdQuote: string, time?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetIdBase' is not null or undefined
            if (assetIdBase === null || assetIdBase === undefined) {
                throw new RequiredError('assetIdBase','Required parameter assetIdBase was null or undefined when calling getSpecificRate.');
            }
            // verify required parameter 'assetIdQuote' is not null or undefined
            if (assetIdQuote === null || assetIdQuote === undefined) {
                throw new RequiredError('assetIdQuote','Required parameter assetIdQuote was null or undefined when calling getSpecificRate.');
            }
            const localVarPath = `/v1/exchangerate/{asset_id_base}/{asset_id_quote}`
                .replace(`{${"asset_id_base"}}`, encodeURIComponent(String(assetIdBase)))
                .replace(`{${"asset_id_quote"}}`, encodeURIComponent(String(assetIdQuote)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = ((time:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the historical exchange rates between two assets in the form of the timeseries.
         * @summary Timeseries data
         * @throws {RequiredError}
         */
        v1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(assetIdBase: string, assetIdQuote: string, periodId?: string, timeStart?: string, timeEnd?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetIdBase' is not null or undefined
            if (assetIdBase === null || assetIdBase === undefined) {
                throw new RequiredError('assetIdBase','Required parameter assetIdBase was null or undefined when calling v1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet.');
            }
            // verify required parameter 'assetIdQuote' is not null or undefined
            if (assetIdQuote === null || assetIdQuote === undefined) {
                throw new RequiredError('assetIdQuote','Required parameter assetIdQuote was null or undefined when calling v1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet.');
            }
            const localVarPath = `/v1/exchangerate/{asset_id_base}/{asset_id_quote}/history`
                .replace(`{${"asset_id_base"}}`, encodeURIComponent(String(assetIdBase)))
                .replace(`{${"asset_id_quote"}}`, encodeURIComponent(String(assetIdQuote)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current exchange rate between requested asset and all other assets.                :::info  If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements.  :::                :::info  You can invert the rates by using Y = 1 / X equation, for example BTC/USD = 1 / (USD/BTC);  :::
         * @summary Get all current rates
         * @throws {RequiredError}
         */
        v1ExchangerateAssetIdBaseGet(assetIdBase: string, filterAssetId?: string, invert?: boolean, time?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetIdBase' is not null or undefined
            if (assetIdBase === null || assetIdBase === undefined) {
                throw new RequiredError('assetIdBase','Required parameter assetIdBase was null or undefined when calling v1ExchangerateAssetIdBaseGet.');
            }
            const localVarPath = `/v1/exchangerate/{asset_id_base}`
                .replace(`{${"asset_id_base"}}`, encodeURIComponent(String(assetIdBase)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterAssetId !== undefined) {
                localVarQueryParameter['filter_asset_id'] = ((filterAssetId:any):string);
            }

            if (invert !== undefined) {
                localVarQueryParameter['invert'] = ((invert:any):string);
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = ((time:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can also obtain historical exchange rates of any asset pair, grouped into time periods.  Get full list of supported time periods available for requesting exchange rates historical timeseries data.                ## Timeseries periods  Time unit | Period identifiers  --- | ---  Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC  Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN  Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS  Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY
         * @summary Timeseries periods
         * @throws {RequiredError}
         */
        v1ExchangerateHistoryPeriodsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/exchangerate/history/periods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ExchangeRatesApiType = { 
    getSpecificRate(assetIdBase: string, assetIdQuote: string, time?: string, options?: RequestOptions): Promise<V1ExchangeRate>,

    v1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(assetIdBase: string, assetIdQuote: string, periodId?: string, timeStart?: string, timeEnd?: string, limit?: number, options?: RequestOptions): Promise<Array<V1ExchangeRatesTimeseriesItem>>,

    v1ExchangerateAssetIdBaseGet(assetIdBase: string, filterAssetId?: string, invert?: boolean, time?: string, options?: RequestOptions): Promise<V1ExchangeRates>,

    v1ExchangerateHistoryPeriodsGet(options?: RequestOptions): Promise<Array<V1TimeseriesPeriod>>,
}

/**
 * ExchangeRatesApi - factory function to inject configuration 
 * @export
 */
export const ExchangeRatesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ExchangeRatesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.                :::info  If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements.  :::
         * @summary Get specific rate
         * @throws {RequiredError}
         */
        getSpecificRate(assetIdBase: string, assetIdQuote: string, time?: string, options?: RequestOptions = {}): Promise<V1ExchangeRate> {
            const localVarFetchArgs = ExchangeRatesApiFetchParamCreator(configuration).getSpecificRate(assetIdBase, assetIdQuote, time, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get the historical exchange rates between two assets in the form of the timeseries.
         * @summary Timeseries data
         * @throws {RequiredError}
         */
        v1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(assetIdBase: string, assetIdQuote: string, periodId?: string, timeStart?: string, timeEnd?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1ExchangeRatesTimeseriesItem>> {
            const localVarFetchArgs = ExchangeRatesApiFetchParamCreator(configuration).v1ExchangerateAssetIdBaseAssetIdQuoteHistoryGet(assetIdBase, assetIdQuote, periodId, timeStart, timeEnd, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get the current exchange rate between requested asset and all other assets.                :::info  If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements.  :::                :::info  You can invert the rates by using Y = 1 / X equation, for example BTC/USD = 1 / (USD/BTC);  :::
         * @summary Get all current rates
         * @throws {RequiredError}
         */
        v1ExchangerateAssetIdBaseGet(assetIdBase: string, filterAssetId?: string, invert?: boolean, time?: string, options?: RequestOptions = {}): Promise<V1ExchangeRates> {
            const localVarFetchArgs = ExchangeRatesApiFetchParamCreator(configuration).v1ExchangerateAssetIdBaseGet(assetIdBase, filterAssetId, invert, time, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * You can also obtain historical exchange rates of any asset pair, grouped into time periods.  Get full list of supported time periods available for requesting exchange rates historical timeseries data.                ## Timeseries periods  Time unit | Period identifiers  --- | ---  Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC  Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN  Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS  Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY
         * @summary Timeseries periods
         * @throws {RequiredError}
         */
        v1ExchangerateHistoryPeriodsGet(options?: RequestOptions = {}): Promise<Array<V1TimeseriesPeriod>> {
            const localVarFetchArgs = ExchangeRatesApiFetchParamCreator(configuration).v1ExchangerateHistoryPeriodsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ExternalMetricsApi - fetch parameter creator
 * @export
 */
export const ExternalMetricsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get asset metrics history from external data providers. Data is typically aggregated daily.
         * @summary Historical metrics for the asset from external sources
         * @throws {RequiredError}
         */
        v1ExternalmetricsAssetHistoryGet(metricId: string, assetId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling v1ExternalmetricsAssetHistoryGet.');
            }
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling v1ExternalmetricsAssetHistoryGet.');
            }
            const localVarPath = `/v1/externalmetrics/asset/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = ((assetId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (timeFormat !== undefined) {
                localVarQueryParameter['time_format'] = ((timeFormat:any):string);
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all metrics that are actually available for the specified asset from external providers.
         * @summary Listing of metrics available for specific asset
         * @throws {RequiredError}
         */
        v1ExternalmetricsAssetListingGet(assetId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling v1ExternalmetricsAssetListingGet.');
            }
            const localVarPath = `/v1/externalmetrics/asset/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = ((assetId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all assets (primarily stablecoins) supported by external data providers.
         * @summary Listing of all supported external assets
         * @throws {RequiredError}
         */
        v1ExternalmetricsAssetsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/externalmetrics/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get chain metrics history from external data providers. Data is typically aggregated daily.
         * @summary Historical metrics for the chain from external sources
         * @throws {RequiredError}
         */
        v1ExternalmetricsChainHistoryGet(metricId: string, chainId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling v1ExternalmetricsChainHistoryGet.');
            }
            // verify required parameter 'chainId' is not null or undefined
            if (chainId === null || chainId === undefined) {
                throw new RequiredError('chainId','Required parameter chainId was null or undefined when calling v1ExternalmetricsChainHistoryGet.');
            }
            const localVarPath = `/v1/externalmetrics/chain/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chain_id'] = ((chainId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (timeFormat !== undefined) {
                localVarQueryParameter['time_format'] = ((timeFormat:any):string);
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all metrics that are actually available for the specified blockchain chain from external providers.
         * @summary Listing of metrics available for specific chain
         * @throws {RequiredError}
         */
        v1ExternalmetricsChainListingGet(chainId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'chainId' is not null or undefined
            if (chainId === null || chainId === undefined) {
                throw new RequiredError('chainId','Required parameter chainId was null or undefined when calling v1ExternalmetricsChainListingGet.');
            }
            const localVarPath = `/v1/externalmetrics/chain/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chain_id'] = ((chainId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all blockchain chains supported by external data providers.
         * @summary Listing of all supported external chains
         * @throws {RequiredError}
         */
        v1ExternalmetricsChainsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/externalmetrics/chains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exchange metrics history from external data providers or internal sources based on metric type.
         * @summary Historical metrics for the exchange from both external and internal sources
         * @throws {RequiredError}
         */
        v1ExternalmetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling v1ExternalmetricsExchangeHistoryGet.');
            }
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1ExternalmetricsExchangeHistoryGet.');
            }
            const localVarPath = `/v1/externalmetrics/exchange/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (timeFormat !== undefined) {
                localVarQueryParameter['time_format'] = ((timeFormat:any):string);
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
         * @summary Listing of metrics available for specific exchange (both external and generic)
         * @throws {RequiredError}
         */
        v1ExternalmetricsExchangeListingGet(exchangeId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1ExternalmetricsExchangeListingGet.');
            }
            const localVarPath = `/v1/externalmetrics/exchange/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
         * @summary Listing of all supported external exchanges
         * @throws {RequiredError}
         */
        v1ExternalmetricsExchangesGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/externalmetrics/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
         * @summary Listing of all supported metrics (both external and generic)
         * @throws {RequiredError}
         */
        v1ExternalmetricsListingGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/externalmetrics/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ExternalMetricsApiType = { 
    v1ExternalmetricsAssetHistoryGet(metricId: string, assetId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions): Promise<Array<Object>>,

    v1ExternalmetricsAssetListingGet(assetId: string, options?: RequestOptions): Promise<Array<V1MetricInfo>>,

    v1ExternalmetricsAssetsGet(options?: RequestOptions): Promise<Array<V1ExternalAsset>>,

    v1ExternalmetricsChainHistoryGet(metricId: string, chainId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions): Promise<Array<Object>>,

    v1ExternalmetricsChainListingGet(chainId: string, options?: RequestOptions): Promise<Array<V1MetricInfo>>,

    v1ExternalmetricsChainsGet(options?: RequestOptions): Promise<Array<V1Chain>>,

    v1ExternalmetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions): Promise<Array<Object>>,

    v1ExternalmetricsExchangeListingGet(exchangeId: string, options?: RequestOptions): Promise<Array<V1MetricInfo>>,

    v1ExternalmetricsExchangesGet(options?: RequestOptions): Promise<Array<V1ExternalExchange>>,

    v1ExternalmetricsListingGet(options?: RequestOptions): Promise<Array<V1MetricInfo>>,
}

/**
 * ExternalMetricsApi - factory function to inject configuration 
 * @export
 */
export const ExternalMetricsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ExternalMetricsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get asset metrics history from external data providers. Data is typically aggregated daily.
         * @summary Historical metrics for the asset from external sources
         * @throws {RequiredError}
         */
        v1ExternalmetricsAssetHistoryGet(metricId: string, assetId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<Object>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsAssetHistoryGet(metricId, assetId, timeStart, timeEnd, timeFormat, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all metrics that are actually available for the specified asset from external providers.
         * @summary Listing of metrics available for specific asset
         * @throws {RequiredError}
         */
        v1ExternalmetricsAssetListingGet(assetId: string, options?: RequestOptions = {}): Promise<Array<V1MetricInfo>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsAssetListingGet(assetId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all assets (primarily stablecoins) supported by external data providers.
         * @summary Listing of all supported external assets
         * @throws {RequiredError}
         */
        v1ExternalmetricsAssetsGet(options?: RequestOptions = {}): Promise<Array<V1ExternalAsset>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsAssetsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get chain metrics history from external data providers. Data is typically aggregated daily.
         * @summary Historical metrics for the chain from external sources
         * @throws {RequiredError}
         */
        v1ExternalmetricsChainHistoryGet(metricId: string, chainId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<Object>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsChainHistoryGet(metricId, chainId, timeStart, timeEnd, timeFormat, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all metrics that are actually available for the specified blockchain chain from external providers.
         * @summary Listing of metrics available for specific chain
         * @throws {RequiredError}
         */
        v1ExternalmetricsChainListingGet(chainId: string, options?: RequestOptions = {}): Promise<Array<V1MetricInfo>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsChainListingGet(chainId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all blockchain chains supported by external data providers.
         * @summary Listing of all supported external chains
         * @throws {RequiredError}
         */
        v1ExternalmetricsChainsGet(options?: RequestOptions = {}): Promise<Array<V1Chain>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsChainsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get exchange metrics history from external data providers or internal sources based on metric type.
         * @summary Historical metrics for the exchange from both external and internal sources
         * @throws {RequiredError}
         */
        v1ExternalmetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<Object>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsExchangeHistoryGet(metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all metrics that are actually available for the specified exchange from both external providers and internal sources.
         * @summary Listing of metrics available for specific exchange (both external and generic)
         * @throws {RequiredError}
         */
        v1ExternalmetricsExchangeListingGet(exchangeId: string, options?: RequestOptions = {}): Promise<Array<V1MetricInfo>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsExchangeListingGet(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all exchanges that have mapping to external data providers for metrics that actually have sources.  Only returns exchanges that are properly mapped to external protocols for metrics with defined sources.
         * @summary Listing of all supported external exchanges
         * @throws {RequiredError}
         */
        v1ExternalmetricsExchangesGet(options?: RequestOptions = {}): Promise<Array<V1ExternalExchange>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsExchangesGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all metrics available from external data providers and internal generic metrics.  External metrics have detailed descriptions, while generic metrics are marked as such.
         * @summary Listing of all supported metrics (both external and generic)
         * @throws {RequiredError}
         */
        v1ExternalmetricsListingGet(options?: RequestOptions = {}): Promise<Array<V1MetricInfo>> {
            const localVarFetchArgs = ExternalMetricsApiFetchParamCreator(configuration).v1ExternalmetricsListingGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetadataApi - fetch parameter creator
 * @export
 */
export const MetadataApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all assets by asset ID
         * @throws {RequiredError}
         */
        v1AssetsAssetIdGet(assetId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling v1AssetsAssetIdGet.');
            }
            const localVarPath = `/v1/assets/{asset_id}`
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
         * @summary List all assets
         * @throws {RequiredError}
         */
        v1AssetsGet(filterAssetId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/assets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterAssetId !== undefined) {
                localVarQueryParameter['filter_asset_id'] = ((filterAssetId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of icons (of the given size) for all the assets.
         * @summary List all asset icons
         * @throws {RequiredError}
         */
        v1AssetsIconsSizeGet(size: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling v1AssetsIconsSizeGet.');
            }
            const localVarPath = `/v1/assets/icons/{size}`
                .replace(`{${"size"}}`, encodeURIComponent(String(size)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all exchanges by exchange_id
         * @throws {RequiredError}
         */
        v1ExchangesExchangeIdGet(exchangeId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1ExchangesExchangeIdGet.');
            }
            const localVarPath = `/v1/exchanges/{exchange_id}`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
         * @summary List all exchanges
         * @throws {RequiredError}
         */
        v1ExchangesGet(filterExchangeId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/exchanges`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterExchangeId !== undefined) {
                localVarQueryParameter['filter_exchange_id'] = ((filterExchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of icons for the exchanges
         * @throws {RequiredError}
         */
        v1ExchangesIconsSizeGet(size: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling v1ExchangesIconsSizeGet.');
            }
            const localVarPath = `/v1/exchanges/icons/{size}`
                .replace(`{${"size"}}`, encodeURIComponent(String(size)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of symbols for the exchange
         * @throws {RequiredError}
         */
        v1SymbolsExchangeIdGet(exchangeId: string, filterSymbolId?: string, filterAssetId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1SymbolsExchangeIdGet.');
            }
            const localVarPath = `/v1/symbols/{exchange_id}`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterSymbolId !== undefined) {
                localVarQueryParameter['filter_symbol_id'] = ((filterSymbolId:any):string);
            }

            if (filterAssetId !== undefined) {
                localVarQueryParameter['filter_asset_id'] = ((filterAssetId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all symbols with optional filtering.                :::info  \"price_precision\" and \"size_precision\" are data precisions and are not always the same precisions used for trading eg. for the \"BINANCE\" exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \"price_precision\" and \"size_precision\". The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | `symbol_id` pattern  --------- | ---------  SPOT | `{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}`  FUTURES | `{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}`  OPTION | `{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}`  PERPETUAL | `{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}`  INDEX | `{exchange_id}_IDX_{index_id}`  CREDIT | `{exchange_id}_CRE_{asset_id_base}`  CONTACT  | `{exchange_id}_COT_{contract_id}`                :::info  In the unlikely event when the \"symbol_id\" for more than one market is the same. We will append the additional term (prefixed with the \"_\") at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of `symbol_type` output variable)                Type | Name | Description  -------- | - | -----------  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for `symbol_type = INDEX`                Variable | Description  --------- | -----------  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for `symbol_type = FUTURES`                Variable | Description  --------- | -----------  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if `future_contract_unit` = `10` and `future_contract_unit_asset` = `BTC`)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for `symbol_type = PERPETUAL`                Variable | Description  --------- | -----------  future_contract_unit | Contact size *(eg. 10 BTC if `future_contract_unit` = `10` and `future_contract_unit_asset` = `BTC`)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for `symbol_type = OPTION`                Variable | Description  --------- | -----------  option_type_is_call | Boolean value representing option type. `true` for Call options, `false` for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be `EUROPEAN` or `AMERICAN`  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for `symbol_type = CONTRACT`                Variable | Description  --------- | -----------  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if `contract_unit` = `10` and `contract_unit_asset` = `BTC`)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
         * @summary List all symbols
         * @throws {RequiredError}
         */
        v1SymbolsGet(filterSymbolId?: string, filterExchangeId?: string, filterAssetId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/symbols`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterSymbolId !== undefined) {
                localVarQueryParameter['filter_symbol_id'] = ((filterSymbolId:any):string);
            }

            if (filterExchangeId !== undefined) {
                localVarQueryParameter['filter_exchange_id'] = ((filterExchangeId:any):string);
            }

            if (filterAssetId !== undefined) {
                localVarQueryParameter['filter_asset_id'] = ((filterAssetId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List symbol mapping for the exchange
         * @throws {RequiredError}
         */
        v1SymbolsMapExchangeIdGet(exchangeId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1SymbolsMapExchangeIdGet.');
            }
            const localVarPath = `/v1/symbols/map/{exchange_id}`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetadataApiType = { 
    v1AssetsAssetIdGet(assetId: string, options?: RequestOptions): Promise<Array<V1Asset>>,

    v1AssetsGet(filterAssetId?: string, options?: RequestOptions): Promise<Array<V1Asset>>,

    v1AssetsIconsSizeGet(size: number, options?: RequestOptions): Promise<Array<V1Icon>>,

    v1ExchangesExchangeIdGet(exchangeId: string, options?: RequestOptions): Promise<Array<V1Exchange>>,

    v1ExchangesGet(filterExchangeId?: string, options?: RequestOptions): Promise<Array<V1Exchange>>,

    v1ExchangesIconsSizeGet(size: number, options?: RequestOptions): Promise<Array<V1Icon>>,

    v1SymbolsExchangeIdGet(exchangeId: string, filterSymbolId?: string, filterAssetId?: string, options?: RequestOptions): Promise<Array<V1Symbol>>,

    v1SymbolsGet(filterSymbolId?: string, filterExchangeId?: string, filterAssetId?: string, options?: RequestOptions): Promise<Array<V1Symbol>>,

    v1SymbolsMapExchangeIdGet(exchangeId: string, options?: RequestOptions): Promise<Array<V1SymbolMapping>>,
}

/**
 * MetadataApi - factory function to inject configuration 
 * @export
 */
export const MetadataApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetadataApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary List all assets by asset ID
         * @throws {RequiredError}
         */
        v1AssetsAssetIdGet(assetId: string, options?: RequestOptions = {}): Promise<Array<V1Asset>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1AssetsAssetIdGet(assetId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Retrieves all assets.                :::info  Our asset identifiers are aligned with the ISO 4217 currency codes standard only for fiat money (government or law regulated currency).  :::                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific asset. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
         * @summary List all assets
         * @throws {RequiredError}
         */
        v1AssetsGet(filterAssetId?: string, options?: RequestOptions = {}): Promise<Array<V1Asset>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1AssetsGet(filterAssetId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets the list of icons (of the given size) for all the assets.
         * @summary List all asset icons
         * @throws {RequiredError}
         */
        v1AssetsIconsSizeGet(size: number, options?: RequestOptions = {}): Promise<Array<V1Icon>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1AssetsIconsSizeGet(size, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List all exchanges by exchange_id
         * @throws {RequiredError}
         */
        v1ExchangesExchangeIdGet(exchangeId: string, options?: RequestOptions = {}): Promise<Array<V1Exchange>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1ExchangesExchangeIdGet(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get a detailed list of exchanges provided by the system.                :::info  Properties of the output are providing aggregated information from across all symbols related to the specific exchange. If you need to calculate your aggregation (e.g., limiting only the particular type of symbols), you should use /v1/symbols endpoint as a data source.  :::
         * @summary List all exchanges
         * @throws {RequiredError}
         */
        v1ExchangesGet(filterExchangeId?: string, options?: RequestOptions = {}): Promise<Array<V1Exchange>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1ExchangesGet(filterExchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List of icons for the exchanges
         * @throws {RequiredError}
         */
        v1ExchangesIconsSizeGet(size: number, options?: RequestOptions = {}): Promise<Array<V1Icon>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1ExchangesIconsSizeGet(size, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List of symbols for the exchange
         * @throws {RequiredError}
         */
        v1SymbolsExchangeIdGet(exchangeId: string, filterSymbolId?: string, filterAssetId?: string, options?: RequestOptions = {}): Promise<Array<V1Symbol>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1SymbolsExchangeIdGet(exchangeId, filterSymbolId, filterAssetId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Retrieves all symbols with optional filtering.                :::info  \"price_precision\" and \"size_precision\" are data precisions and are not always the same precisions used for trading eg. for the \"BINANCE\" exchanges.  :::                :::info  You should not assume that the market data will be always within the resolution provided by the \"price_precision\" and \"size_precision\". The fact that the precision values can be derived from a posterior implies the fact that this data could be delayed, also it can be changed by the data source without notice and we will immediately deliver data with the new precision while could not update the precision values in this endpoint immediately.  :::                ### Symbol identifier                Our symbol identifier is created using a pattern that depends on symbol type.                Type | `symbol_id` pattern  --------- | ---------  SPOT | `{exchange_id}_SPOT_{asset_id_base}_{asset_id_quote}`  FUTURES | `{exchange_id}_FTS_{asset_id_base}_{asset_id_quote}_{YYMMDD of future_delivery_time}`  OPTION | `{exchange_id}_OPT_{asset_id_base}_{asset_id_quote}_{YYMMDD of option_expiration_time}_{option_strike_price}_{option_type_is_call as C/P}`  PERPETUAL | `{exchange_id}_PERP_{asset_id_base}_{asset_id_quote}`  INDEX | `{exchange_id}_IDX_{index_id}`  CREDIT | `{exchange_id}_CRE_{asset_id_base}`  CONTACT  | `{exchange_id}_COT_{contract_id}`                :::info  In the unlikely event when the \"symbol_id\" for more than one market is the same. We will append the additional term (prefixed with the \"_\") at the end of the duplicated identifiers to differentiate them.  :::info                ### Symbol types list (enumeration of `symbol_type` output variable)                Type | Name | Description  -------- | - | -----------  SPOT | FX Spot | Agreement to exchange one asset for another one *(e.g. Buy BTC for USD)*  FUTURES | Futures contract | FX Spot derivative contract where traders agree to trade fx spot at predetermined future time  OPTION | Option contract | FX Spot derivative contract where traders agree to trade right to require buy or sell of fx spot at agreed price on exercise date  PERPETUAL | Perpetual contract | FX Spot derivative contract where traders agree to trade fx spot continously without predetermined future delivery time  INDEX | Index | Statistical composite that measures changes in the economy or markets.  CREDIT | Credit/Funding | Margin funding contract. Order book displays lending offers and borrow bids. Price represents the daily rate.  CONTRACT | Contract | Represents other types of financial instruments *(e.g. spreads, interest rate swap)*                ### Additional output variables for `symbol_type = INDEX`                Variable | Description  --------- | -----------  index_id | Index identifier  index_display_name | Human readable name of the index *(optional)*  index_display_description | Description of the index *(optional)*                ### Additional output variables for `symbol_type = FUTURES`                Variable | Description  --------- | -----------  future_delivery_time | Predetermined time of futures contract delivery date in ISO 8601  future_contract_unit | Contact size *(eg. 10 BTC if `future_contract_unit` = `10` and `future_contract_unit_asset` = `BTC`)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for `symbol_type = PERPETUAL`                Variable | Description  --------- | -----------  future_contract_unit | Contact size *(eg. 10 BTC if `future_contract_unit` = `10` and `future_contract_unit_asset` = `BTC`)*  future_contract_unit_asset | Identifier of the asset used to denominate the contract unit                ### Additional output variables for `symbol_type = OPTION`                Variable | Description  --------- | -----------  option_type_is_call | Boolean value representing option type. `true` for Call options, `false` for Put options  option_strike_price | Price at which option contract can be exercised  option_contract_unit | Base asset amount of underlying spot which single option represents  option_exercise_style | Option exercise style. Can be `EUROPEAN` or `AMERICAN`  option_expiration_time | Option contract expiration time in ISO 8601                ### Additional output variables for `symbol_type = CONTRACT`                Variable | Description  --------- | -----------  contract_delivery_time | Predetermined time of contract delivery date in ISO 8601  contract_unit | Contact size *(eg. 10 BTC if `contract_unit` = `10` and `contract_unit_asset` = `BTC`)*  contract_unit_asset | Identifier of the asset used to denominate the contract unit  contract_id | Identifier of contract by the exchange
         * @summary List all symbols
         * @throws {RequiredError}
         */
        v1SymbolsGet(filterSymbolId?: string, filterExchangeId?: string, filterAssetId?: string, options?: RequestOptions = {}): Promise<Array<V1Symbol>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1SymbolsGet(filterSymbolId, filterExchangeId, filterAssetId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List symbol mapping for the exchange
         * @throws {RequiredError}
         */
        v1SymbolsMapExchangeIdGet(exchangeId: string, options?: RequestOptions = {}): Promise<Array<V1SymbolMapping>> {
            const localVarFetchArgs = MetadataApiFetchParamCreator(configuration).v1SymbolsMapExchangeIdGet(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MetricsApi - fetch parameter creator
 * @export
 */
export const MetricsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current asset metrics.
         * @summary Current metrics for given asset
         * @throws {RequiredError}
         */
        v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/metrics/asset/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = ((assetId:any):string);
            }

            if (assetIdExternal !== undefined) {
                localVarQueryParameter['asset_id_external'] = ((assetIdExternal:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get asset metrics history.
         * @summary Historical metrics for asset
         * @throws {RequiredError}
         */
        v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling v1MetricsAssetHistoryGet.');
            }
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1MetricsAssetHistoryGet.');
            }
            const localVarPath = `/v1/metrics/asset/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = ((assetId:any):string);
            }

            if (assetIdExternal !== undefined) {
                localVarQueryParameter['asset_id_external'] = ((assetIdExternal:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (timeFormat !== undefined) {
                localVarQueryParameter['time_format'] = ((timeFormat:any):string);
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data metrics for asset.
         * @summary Listing of all supported metrics for asset
         * @throws {RequiredError}
         */
        v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/metrics/asset/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            if (chainId !== undefined) {
                localVarQueryParameter['chain_id'] = ((chainId:any):string);
            }

            if (networkId !== undefined) {
                localVarQueryParameter['network_id'] = ((networkId:any):string);
            }

            if (assetId !== undefined) {
                localVarQueryParameter['asset_id'] = ((assetId:any):string);
            }

            if (assetIdExternal !== undefined) {
                localVarQueryParameter['asset_id_external'] = ((assetIdExternal:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current exchange metrics values.
         * @summary Current metrics for given exchange
         * @throws {RequiredError}
         */
        v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1MetricsExchangeCurrentGet.');
            }
            const localVarPath = `/v1/metrics/exchange/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get exchange metrics history.
         * @summary Historical metrics for the exchange
         * @throws {RequiredError}
         */
        v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling v1MetricsExchangeHistoryGet.');
            }
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1MetricsExchangeHistoryGet.');
            }
            const localVarPath = `/v1/metrics/exchange/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (timeFormat !== undefined) {
                localVarQueryParameter['time_format'] = ((timeFormat:any):string);
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data metrics for exchange.
         * @summary Listing of all supported exchange metrics
         * @throws {RequiredError}
         */
        v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1MetricsExchangeListingGet.');
            }
            const localVarPath = `/v1/metrics/exchange/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all data metrics.
         * @summary Listing of all supported metrics by CoinAPI
         * @throws {RequiredError}
         */
        v1MetricsListingGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/metrics/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current symbol metrics.
         * @summary Current metrics for given symbol
         * @throws {RequiredError}
         */
        v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/metrics/symbol/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (symbolId !== undefined) {
                localVarQueryParameter['symbol_id'] = ((symbolId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get symbol metrics history.
         * @summary Historical metrics for symbol
         * @throws {RequiredError}
         */
        v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling v1MetricsSymbolHistoryGet.');
            }
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1MetricsSymbolHistoryGet.');
            }
            const localVarPath = `/v1/metrics/symbol/history`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (symbolId !== undefined) {
                localVarQueryParameter['symbol_id'] = ((symbolId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):Date).toISOString();
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):Date).toISOString();
            }

            if (timeFormat !== undefined) {
                localVarQueryParameter['time_format'] = ((timeFormat:any):string);
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get data metrics for symbol.
         * @summary Listing of all supported metrics for symbol
         * @throws {RequiredError}
         */
        v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/metrics/symbol/listing`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (metricId !== undefined) {
                localVarQueryParameter['metric_id'] = ((metricId:any):string);
            }

            if (exchangeId !== undefined) {
                localVarQueryParameter['exchange_id'] = ((exchangeId:any):string);
            }

            if (symbolId !== undefined) {
                localVarQueryParameter['symbol_id'] = ((symbolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MetricsApiType = { 
    v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, options?: RequestOptions): Promise<Array<V1GeneralData>>,

    v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions): Promise<Array<V1MetricData>>,

    v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, options?: RequestOptions): Promise<Array<V1ListingItem>>,

    v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, options?: RequestOptions): Promise<Array<V1GeneralData>>,

    v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions): Promise<Array<V1MetricData>>,

    v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, options?: RequestOptions): Promise<Array<V1ListingItem>>,

    v1MetricsListingGet(options?: RequestOptions): Promise<Array<V1Metric>>,

    v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, options?: RequestOptions): Promise<Array<V1GeneralData>>,

    v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions): Promise<Array<V1MetricData>>,

    v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, options?: RequestOptions): Promise<Array<V1ListingItem>>,
}

/**
 * MetricsApi - factory function to inject configuration 
 * @export
 */
export const MetricsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MetricsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get current asset metrics.
         * @summary Current metrics for given asset
         * @throws {RequiredError}
         */
        v1MetricsAssetCurrentGet(metricId?: string, assetId?: string, assetIdExternal?: string, exchangeId?: string, options?: RequestOptions = {}): Promise<Array<V1GeneralData>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsAssetCurrentGet(metricId, assetId, assetIdExternal, exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get asset metrics history.
         * @summary Historical metrics for asset
         * @throws {RequiredError}
         */
        v1MetricsAssetHistoryGet(metricId: string, exchangeId: string, assetId?: string, assetIdExternal?: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1MetricData>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsAssetHistoryGet(metricId, exchangeId, assetId, assetIdExternal, timeStart, timeEnd, timeFormat, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get data metrics for asset.
         * @summary Listing of all supported metrics for asset
         * @throws {RequiredError}
         */
        v1MetricsAssetListingGet(metricId?: string, exchangeId?: string, chainId?: string, networkId?: string, assetId?: string, assetIdExternal?: string, options?: RequestOptions = {}): Promise<Array<V1ListingItem>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsAssetListingGet(metricId, exchangeId, chainId, networkId, assetId, assetIdExternal, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get current exchange metrics values.
         * @summary Current metrics for given exchange
         * @throws {RequiredError}
         */
        v1MetricsExchangeCurrentGet(exchangeId: string, metricId?: string, options?: RequestOptions = {}): Promise<Array<V1GeneralData>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsExchangeCurrentGet(exchangeId, metricId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get exchange metrics history.
         * @summary Historical metrics for the exchange
         * @throws {RequiredError}
         */
        v1MetricsExchangeHistoryGet(metricId: string, exchangeId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1MetricData>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsExchangeHistoryGet(metricId, exchangeId, timeStart, timeEnd, timeFormat, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get data metrics for exchange.
         * @summary Listing of all supported exchange metrics
         * @throws {RequiredError}
         */
        v1MetricsExchangeListingGet(exchangeId: string, metricId?: string, options?: RequestOptions = {}): Promise<Array<V1ListingItem>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsExchangeListingGet(exchangeId, metricId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get all data metrics.
         * @summary Listing of all supported metrics by CoinAPI
         * @throws {RequiredError}
         */
        v1MetricsListingGet(options?: RequestOptions = {}): Promise<Array<V1Metric>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsListingGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get current symbol metrics.
         * @summary Current metrics for given symbol
         * @throws {RequiredError}
         */
        v1MetricsSymbolCurrentGet(metricId?: string, symbolId?: string, exchangeId?: string, options?: RequestOptions = {}): Promise<Array<V1GeneralData>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsSymbolCurrentGet(metricId, symbolId, exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get symbol metrics history.
         * @summary Historical metrics for symbol
         * @throws {RequiredError}
         */
        v1MetricsSymbolHistoryGet(metricId: string, symbolId: string, timeStart?: Date, timeEnd?: Date, timeFormat?: string, periodId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1MetricData>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsSymbolHistoryGet(metricId, symbolId, timeStart, timeEnd, timeFormat, periodId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get data metrics for symbol.
         * @summary Listing of all supported metrics for symbol
         * @throws {RequiredError}
         */
        v1MetricsSymbolListingGet(metricId?: string, exchangeId?: string, symbolId?: string, options?: RequestOptions = {}): Promise<Array<V1ListingItem>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).v1MetricsSymbolListingGet(metricId, exchangeId, symbolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OhlcvApi - fetch parameter creator
 * @export
 */
export const OhlcvApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get OHLCV timeseries data returned in time ascending order. Data can be requested by the period and for the specific exchange eg `BITSTAMP`                :::info  The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay.  The difference between `time_end` and `time_start` cannot be higher than 1 day.  The `period_id` cannot be higher than `1DAY`.  :::
         * @summary Historical data by exchange
         * @throws {RequiredError}
         */
        v1OhlcvExchangesExchangeIdHistoryGet(exchangeId: string, periodId: string, timeStart: string, timeEnd: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1OhlcvExchangesExchangeIdHistoryGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1OhlcvExchangesExchangeIdHistoryGet.');
            }
            // verify required parameter 'timeStart' is not null or undefined
            if (timeStart === null || timeStart === undefined) {
                throw new RequiredError('timeStart','Required parameter timeStart was null or undefined when calling v1OhlcvExchangesExchangeIdHistoryGet.');
            }
            // verify required parameter 'timeEnd' is not null or undefined
            if (timeEnd === null || timeEnd === undefined) {
                throw new RequiredError('timeEnd','Required parameter timeEnd was null or undefined when calling v1OhlcvExchangesExchangeIdHistoryGet.');
            }
            const localVarPath = `/v1/ohlcv/exchanges/{exchange_id}/history`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get full list of supported time periods available for requesting OHLCV timeseries data.                ### Available periods                Time unit | Period identifiers  --------- | -----------  Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC  Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN  Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS  Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY  Month | 1MTH, 2MTH, 3MTH, 4MTH, 6MTH  Year | 1YRS, 2YRS, 3YRS, 4YRS, 5YRS                :::tip  You can assume that we will not remove any periods from this response, however, we may add new ones.  :::
         * @summary List all periods
         * @throws {RequiredError}
         */
        v1OhlcvPeriodsGet(options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/ohlcv/periods`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OHLCV timeseries data returned in time ascending order. Data can be requested by the period and for the specific symbol eg `BITSTAMP_SPOT_BTC_USD`, if you need to query timeseries by asset pairs eg. `BTC/USD`, then please reffer to the Exchange Rates Timeseries data                :::info  The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1OhlcvSymbolIdHistoryGet(symbolId: string, periodId: string, timeStart?: string, timeEnd?: string, limit?: number, includeEmptyItems?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OhlcvSymbolIdHistoryGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1OhlcvSymbolIdHistoryGet.');
            }
            const localVarPath = `/v1/ohlcv/{symbol_id}/history`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (includeEmptyItems !== undefined) {
                localVarQueryParameter['include_empty_items'] = ((includeEmptyItems:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OHLCV latest timeseries data returned in time descending order. Data can be requested by the period and for the specific symbol eg `BITSTAMP_SPOT_BTC_USD`, if you need to query timeseries by asset pairs eg. `BTC/USD`, then please reffer to the Exchange Rates Timeseries data                :::info  OHLCV Latest endpoint is just the shortcut to the OHLCV Historical endpoint with substituted `time_start` and `time_end` parameters.   The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay.  :::
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1OhlcvSymbolIdLatestGet(symbolId: string, periodId: string, limit?: number, includeEmptyItems?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OhlcvSymbolIdLatestGet.');
            }
            // verify required parameter 'periodId' is not null or undefined
            if (periodId === null || periodId === undefined) {
                throw new RequiredError('periodId','Required parameter periodId was null or undefined when calling v1OhlcvSymbolIdLatestGet.');
            }
            const localVarPath = `/v1/ohlcv/{symbol_id}/latest`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (periodId !== undefined) {
                localVarQueryParameter['period_id'] = ((periodId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (includeEmptyItems !== undefined) {
                localVarQueryParameter['include_empty_items'] = ((includeEmptyItems:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OhlcvApiType = { 
    v1OhlcvExchangesExchangeIdHistoryGet(exchangeId: string, periodId: string, timeStart: string, timeEnd: string, options?: RequestOptions): Promise<Array<ModelsExchangeTimeseriesItem>>,

    v1OhlcvPeriodsGet(options?: RequestOptions): Promise<Array<V1TimeseriesPeriod>>,

    v1OhlcvSymbolIdHistoryGet(symbolId: string, periodId: string, timeStart?: string, timeEnd?: string, limit?: number, includeEmptyItems?: boolean, options?: RequestOptions): Promise<Array<V1TimeseriesItem>>,

    v1OhlcvSymbolIdLatestGet(symbolId: string, periodId: string, limit?: number, includeEmptyItems?: boolean, options?: RequestOptions): Promise<Array<V1TimeseriesItem>>,
}

/**
 * OhlcvApi - factory function to inject configuration 
 * @export
 */
export const OhlcvApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OhlcvApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get OHLCV timeseries data returned in time ascending order. Data can be requested by the period and for the specific exchange eg `BITSTAMP`                :::info  The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay.  The difference between `time_end` and `time_start` cannot be higher than 1 day.  The `period_id` cannot be higher than `1DAY`.  :::
         * @summary Historical data by exchange
         * @throws {RequiredError}
         */
        v1OhlcvExchangesExchangeIdHistoryGet(exchangeId: string, periodId: string, timeStart: string, timeEnd: string, options?: RequestOptions = {}): Promise<Array<ModelsExchangeTimeseriesItem>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvExchangesExchangeIdHistoryGet(exchangeId, periodId, timeStart, timeEnd, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get full list of supported time periods available for requesting OHLCV timeseries data.                ### Available periods                Time unit | Period identifiers  --------- | -----------  Second | 1SEC, 2SEC, 3SEC, 4SEC, 5SEC, 6SEC, 10SEC, 15SEC, 20SEC, 30SEC  Minute | 1MIN, 2MIN, 3MIN, 4MIN, 5MIN, 6MIN, 10MIN, 15MIN, 20MIN, 30MIN  Hour | 1HRS, 2HRS, 3HRS, 4HRS, 6HRS, 8HRS, 12HRS  Day | 1DAY, 2DAY, 3DAY, 5DAY, 7DAY, 10DAY  Month | 1MTH, 2MTH, 3MTH, 4MTH, 6MTH  Year | 1YRS, 2YRS, 3YRS, 4YRS, 5YRS                :::tip  You can assume that we will not remove any periods from this response, however, we may add new ones.  :::
         * @summary List all periods
         * @throws {RequiredError}
         */
        v1OhlcvPeriodsGet(options?: RequestOptions = {}): Promise<Array<V1TimeseriesPeriod>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvPeriodsGet(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get OHLCV timeseries data returned in time ascending order. Data can be requested by the period and for the specific symbol eg `BITSTAMP_SPOT_BTC_USD`, if you need to query timeseries by asset pairs eg. `BTC/USD`, then please reffer to the Exchange Rates Timeseries data                :::info  The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1OhlcvSymbolIdHistoryGet(symbolId: string, periodId: string, timeStart?: string, timeEnd?: string, limit?: number, includeEmptyItems?: boolean, options?: RequestOptions = {}): Promise<Array<V1TimeseriesItem>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvSymbolIdHistoryGet(symbolId, periodId, timeStart, timeEnd, limit, includeEmptyItems, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get OHLCV latest timeseries data returned in time descending order. Data can be requested by the period and for the specific symbol eg `BITSTAMP_SPOT_BTC_USD`, if you need to query timeseries by asset pairs eg. `BTC/USD`, then please reffer to the Exchange Rates Timeseries data                :::info  OHLCV Latest endpoint is just the shortcut to the OHLCV Historical endpoint with substituted `time_start` and `time_end` parameters.   The OHLCV Historical endpoint data can be delayed a few seconds. Use OHLCV real-time data stream to get data without delay.  :::
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1OhlcvSymbolIdLatestGet(symbolId: string, periodId: string, limit?: number, includeEmptyItems?: boolean, options?: RequestOptions = {}): Promise<Array<V1TimeseriesItem>> {
            const localVarFetchArgs = OhlcvApiFetchParamCreator(configuration).v1OhlcvSymbolIdLatestGet(symbolId, periodId, limit, includeEmptyItems, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OptionsApi - fetch parameter creator
 * @export
 */
export const OptionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current options data for a specific exchange.    Returns option data grouped by underlying asset, quote currency, and expiration time,  with quotes for both calls and puts at each strike price.
         * @summary Current data by Exchange
         * @throws {RequiredError}
         */
        v1OptionsExchangeIdCurrentGet(exchangeId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'exchangeId' is not null or undefined
            if (exchangeId === null || exchangeId === undefined) {
                throw new RequiredError('exchangeId','Required parameter exchangeId was null or undefined when calling v1OptionsExchangeIdCurrentGet.');
            }
            const localVarPath = `/v1/options/{exchange_id}/current`
                .replace(`{${"exchange_id"}}`, encodeURIComponent(String(exchangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OptionsApiType = { 
    v1OptionsExchangeIdCurrentGet(exchangeId: string, options?: RequestOptions): Promise<Array<OptionsOptionExchangeGroup>>,
}

/**
 * OptionsApi - factory function to inject configuration 
 * @export
 */
export const OptionsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OptionsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get current options data for a specific exchange.    Returns option data grouped by underlying asset, quote currency, and expiration time,  with quotes for both calls and puts at each strike price.
         * @summary Current data by Exchange
         * @throws {RequiredError}
         */
        v1OptionsExchangeIdCurrentGet(exchangeId: string, options?: RequestOptions = {}): Promise<Array<OptionsOptionExchangeGroup>> {
            const localVarFetchArgs = OptionsApiFetchParamCreator(configuration).v1OptionsExchangeIdCurrentGet(exchangeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrderBookApi - fetch parameter creator
 * @export
 */
export const OrderBookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the current order book for the specified symbol.
         * @summary Get current order book
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdCurrentGet(symbolId: string, limitLevels?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OrderbooksSymbolIdCurrentGet.');
            }
            const localVarPath = `/v1/orderbooks/{symbol_id}/current`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (limitLevels !== undefined) {
                localVarQueryParameter['limit_levels'] = ((limitLevels:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current depth of the order book for the specified symbol.
         * @summary Current depth of the order book
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdDepthCurrentGet(symbolId: string, limitLevels?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OrderbooksSymbolIdDepthCurrentGet.');
            }
            const localVarPath = `/v1/orderbooks/{symbol_id}/depth/current`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (limitLevels !== undefined) {
                localVarQueryParameter['limit_levels'] = ((limitLevels:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.                :::info  The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels.  :::    :::warning  The \'time_start\' and \'time_end\' parameters must be from the same day as this endpoint provides intraday data only for specific day.  Please use the \'date\' parameter instead for querying data for a specific day without filter.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, limitLevels?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OrderbooksSymbolIdHistoryGet.');
            }
            const localVarPath = `/v1/orderbooks/{symbol_id}/history`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (limitLevels !== undefined) {
                localVarQueryParameter['limit_levels'] = ((limitLevels:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get latest order book snapshots for a specific symbol, returned in time descending order.                :::info  The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels.  :::
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdLatestGet(symbolId: string, limit?: number, limitLevels?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1OrderbooksSymbolIdLatestGet.');
            }
            const localVarPath = `/v1/orderbooks/{symbol_id}/latest`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (limitLevels !== undefined) {
                localVarQueryParameter['limit_levels'] = ((limitLevels:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrderBookApiType = { 
    v1OrderbooksSymbolIdCurrentGet(symbolId: string, limitLevels?: number, options?: RequestOptions): Promise<V1OrderBookBase>,

    v1OrderbooksSymbolIdDepthCurrentGet(symbolId: string, limitLevels?: number, options?: RequestOptions): Promise<V1OrderBookDepth>,

    v1OrderbooksSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, limitLevels?: number, options?: RequestOptions): Promise<Array<V1OrderBook>>,

    v1OrderbooksSymbolIdLatestGet(symbolId: string, limit?: number, limitLevels?: number, options?: RequestOptions): Promise<Array<V1OrderBook>>,
}

/**
 * OrderBookApi - factory function to inject configuration 
 * @export
 */
export const OrderBookApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrderBookApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Retrieves the current order book for the specified symbol.
         * @summary Get current order book
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdCurrentGet(symbolId: string, limitLevels?: number, options?: RequestOptions = {}): Promise<V1OrderBookBase> {
            const localVarFetchArgs = OrderBookApiFetchParamCreator(configuration).v1OrderbooksSymbolIdCurrentGet(symbolId, limitLevels, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Retrieves the current depth of the order book for the specified symbol.
         * @summary Current depth of the order book
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdDepthCurrentGet(symbolId: string, limitLevels?: number, options?: RequestOptions = {}): Promise<V1OrderBookDepth> {
            const localVarFetchArgs = OrderBookApiFetchParamCreator(configuration).v1OrderbooksSymbolIdDepthCurrentGet(symbolId, limitLevels, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get historical order book snapshots for a specific symbol within time range, returned in time ascending order.                :::info  The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels.  :::    :::warning  The \'time_start\' and \'time_end\' parameters must be from the same day as this endpoint provides intraday data only for specific day.  Please use the \'date\' parameter instead for querying data for a specific day without filter.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, limitLevels?: number, options?: RequestOptions = {}): Promise<Array<V1OrderBook>> {
            const localVarFetchArgs = OrderBookApiFetchParamCreator(configuration).v1OrderbooksSymbolIdHistoryGet(symbolId, _date, timeStart, timeEnd, limit, limitLevels, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get latest order book snapshots for a specific symbol, returned in time descending order.                :::info  The historical order book data via the REST API is currently limited by a number of updates and to the maximum number of 20 levels.  :::
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1OrderbooksSymbolIdLatestGet(symbolId: string, limit?: number, limitLevels?: number, options?: RequestOptions = {}): Promise<Array<V1OrderBook>> {
            const localVarFetchArgs = OrderBookApiFetchParamCreator(configuration).v1OrderbooksSymbolIdLatestGet(symbolId, limit, limitLevels, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * OrderBookL3Api - fetch parameter creator
 * @export
 */
export const OrderBookL3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Current order books
         * @throws {RequiredError}
         */
        v1Orderbooks3CurrentGet(filterSymbolId?: string, limitLevels?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/orderbooks3/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterSymbolId !== undefined) {
                localVarQueryParameter['filter_symbol_id'] = ((filterSymbolId:any):string);
            }

            if (limitLevels !== undefined) {
                localVarQueryParameter['limit_levels'] = ((limitLevels:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the current order book for the specified symbol.
         * @summary Current order book by symbol_id
         * @throws {RequiredError}
         */
        v1Orderbooks3SymbolIdCurrentGet(symbolId: string, limitLevels?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1Orderbooks3SymbolIdCurrentGet.');
            }
            const localVarPath = `/v1/orderbooks3/{symbol_id}/current`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (limitLevels !== undefined) {
                localVarQueryParameter['limit_levels'] = ((limitLevels:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type OrderBookL3ApiType = { 
    v1Orderbooks3CurrentGet(filterSymbolId?: string, limitLevels?: number, options?: RequestOptions): Promise<Array<V1OrderBookBase>>,

    v1Orderbooks3SymbolIdCurrentGet(symbolId: string, limitLevels?: number, options?: RequestOptions): Promise<V1OrderBookBase>,
}

/**
 * OrderBookL3Api - factory function to inject configuration 
 * @export
 */
export const OrderBookL3Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): OrderBookL3ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Current order books
         * @throws {RequiredError}
         */
        v1Orderbooks3CurrentGet(filterSymbolId?: string, limitLevels?: number, options?: RequestOptions = {}): Promise<Array<V1OrderBookBase>> {
            const localVarFetchArgs = OrderBookL3ApiFetchParamCreator(configuration).v1Orderbooks3CurrentGet(filterSymbolId, limitLevels, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Retrieves the current order book for the specified symbol.
         * @summary Current order book by symbol_id
         * @throws {RequiredError}
         */
        v1Orderbooks3SymbolIdCurrentGet(symbolId: string, limitLevels?: number, options?: RequestOptions = {}): Promise<V1OrderBookBase> {
            const localVarFetchArgs = OrderBookL3ApiFetchParamCreator(configuration).v1Orderbooks3SymbolIdCurrentGet(symbolId, limitLevels, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * QuotesApi - fetch parameter creator
 * @export
 */
export const QuotesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get current quotes for all symbols or for a specific symbol.                :::info  When requesting current data for a specific symbol, output is not encapsulated into JSON array as only one item is returned.  :::
         * @summary Current data
         * @throws {RequiredError}
         */
        v1QuotesCurrentGet(filterSymbolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/quotes/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterSymbolId !== undefined) {
                localVarQueryParameter['filter_symbol_id'] = ((filterSymbolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get latest updates of the quotes up to 1 minute ago. Latest data is always returned in time descending order.
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1QuotesLatestGet(filterSymbolId?: string, limit?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/quotes/latest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterSymbolId !== undefined) {
                localVarQueryParameter['filter_symbol_id'] = ((filterSymbolId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Current quotes for a specific symbol
         * @throws {RequiredError}
         */
        v1QuotesSymbolIdCurrentGet(symbolId: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1QuotesSymbolIdCurrentGet.');
            }
            const localVarPath = `/v1/quotes/{symbol_id}/current`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get historical quote updates within requested time range, returned in time ascending order.    :::warning  The \'time_start\' and \'time_end\' parameters must be from the same day as this endpoint provides intraday data only for specific day.  Please use the \'date\' parameter instead for querying data for a specific day without filter.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1QuotesSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1QuotesSymbolIdHistoryGet.');
            }
            const localVarPath = `/v1/quotes/{symbol_id}/history`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Latest quote updates for a specific symbol
         * @throws {RequiredError}
         */
        v1QuotesSymbolIdLatestGet(symbolId: string, limit?: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1QuotesSymbolIdLatestGet.');
            }
            const localVarPath = `/v1/quotes/{symbol_id}/latest`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type QuotesApiType = { 
    v1QuotesCurrentGet(filterSymbolId?: string, options?: RequestOptions): Promise<Array<V1QuoteTrade>>,

    v1QuotesLatestGet(filterSymbolId?: string, limit?: number, options?: RequestOptions): Promise<Array<V1Quote>>,

    v1QuotesSymbolIdCurrentGet(symbolId: string, options?: RequestOptions): Promise<V1QuoteTrade>,

    v1QuotesSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, options?: RequestOptions): Promise<Array<V1Quote>>,

    v1QuotesSymbolIdLatestGet(symbolId: string, limit?: number, options?: RequestOptions): Promise<Array<V1Quote>>,
}

/**
 * QuotesApi - factory function to inject configuration 
 * @export
 */
export const QuotesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): QuotesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get current quotes for all symbols or for a specific symbol.                :::info  When requesting current data for a specific symbol, output is not encapsulated into JSON array as only one item is returned.  :::
         * @summary Current data
         * @throws {RequiredError}
         */
        v1QuotesCurrentGet(filterSymbolId?: string, options?: RequestOptions = {}): Promise<Array<V1QuoteTrade>> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).v1QuotesCurrentGet(filterSymbolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get latest updates of the quotes up to 1 minute ago. Latest data is always returned in time descending order.
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1QuotesLatestGet(filterSymbolId?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1Quote>> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).v1QuotesLatestGet(filterSymbolId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Current quotes for a specific symbol
         * @throws {RequiredError}
         */
        v1QuotesSymbolIdCurrentGet(symbolId: string, options?: RequestOptions = {}): Promise<V1QuoteTrade> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).v1QuotesSymbolIdCurrentGet(symbolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get historical quote updates within requested time range, returned in time ascending order.    :::warning  The \'time_start\' and \'time_end\' parameters must be from the same day as this endpoint provides intraday data only for specific day.  Please use the \'date\' parameter instead for querying data for a specific day without filter.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1QuotesSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1Quote>> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).v1QuotesSymbolIdHistoryGet(symbolId, _date, timeStart, timeEnd, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Latest quote updates for a specific symbol
         * @throws {RequiredError}
         */
        v1QuotesSymbolIdLatestGet(symbolId: string, limit?: number, options?: RequestOptions = {}): Promise<Array<V1Quote>> {
            const localVarFetchArgs = QuotesApiFetchParamCreator(configuration).v1QuotesSymbolIdLatestGet(symbolId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * TradesApi - fetch parameter creator
 * @export
 */
export const TradesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1TradesLatestGet(filterSymbolId?: string, includeId?: boolean, limit?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/v1/trades/latest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (filterSymbolId !== undefined) {
                localVarQueryParameter['filter_symbol_id'] = ((filterSymbolId:any):string);
            }

            if (includeId !== undefined) {
                localVarQueryParameter['include_id'] = ((includeId:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get history transactions from specific symbol, returned in time ascending order.    :::warning  The \'time_start\' and \'time_end\' parameters must be from the same day as this endpoint provides intraday data only for specific day.  Please use the \'date\' parameter instead for querying data for a specific day without filter.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1TradesSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, includeId?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1TradesSymbolIdHistoryGet.');
            }
            const localVarPath = `/v1/trades/{symbol_id}/history`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):string);
            }

            if (timeStart !== undefined) {
                localVarQueryParameter['time_start'] = ((timeStart:any):string);
            }

            if (timeEnd !== undefined) {
                localVarQueryParameter['time_end'] = ((timeEnd:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (includeId !== undefined) {
                localVarQueryParameter['include_id'] = ((includeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
         * @summary Latest data by symbol_id
         * @throws {RequiredError}
         */
        v1TradesSymbolIdLatestGet(symbolId: string, limit?: number, includeId?: boolean, options: RequestOptions): FetchArgs {
            // verify required parameter 'symbolId' is not null or undefined
            if (symbolId === null || symbolId === undefined) {
                throw new RequiredError('symbolId','Required parameter symbolId was null or undefined when calling v1TradesSymbolIdLatestGet.');
            }
            const localVarPath = `/v1/trades/{symbol_id}/latest`
                .replace(`{${"symbol_id"}}`, encodeURIComponent(String(symbolId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-CoinAPI-Key")
                    : configuration.apiKey;
                localVarHeaderParameter["X-CoinAPI-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (includeId !== undefined) {
                localVarQueryParameter['include_id'] = ((includeId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type TradesApiType = { 
    v1TradesLatestGet(filterSymbolId?: string, includeId?: boolean, limit?: number, options?: RequestOptions): Promise<Array<V1Trade>>,

    v1TradesSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, includeId?: boolean, options?: RequestOptions): Promise<Array<V1Trade>>,

    v1TradesSymbolIdLatestGet(symbolId: string, limit?: number, includeId?: boolean, options?: RequestOptions): Promise<Array<V1Trade>>,
}

/**
 * TradesApi - factory function to inject configuration 
 * @export
 */
export const TradesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): TradesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
         * @summary Latest data
         * @throws {RequiredError}
         */
        v1TradesLatestGet(filterSymbolId?: string, includeId?: boolean, limit?: number, options?: RequestOptions = {}): Promise<Array<V1Trade>> {
            const localVarFetchArgs = TradesApiFetchParamCreator(configuration).v1TradesLatestGet(filterSymbolId, includeId, limit, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get history transactions from specific symbol, returned in time ascending order.    :::warning  The \'time_start\' and \'time_end\' parameters must be from the same day as this endpoint provides intraday data only for specific day.  Please use the \'date\' parameter instead for querying data for a specific day without filter.  :::
         * @summary Historical data
         * @throws {RequiredError}
         */
        v1TradesSymbolIdHistoryGet(symbolId: string, _date?: string, timeStart?: string, timeEnd?: string, limit?: number, includeId?: boolean, options?: RequestOptions = {}): Promise<Array<V1Trade>> {
            const localVarFetchArgs = TradesApiFetchParamCreator(configuration).v1TradesSymbolIdHistoryGet(symbolId, _date, timeStart, timeEnd, limit, includeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Get latest trades executed up to 1 minute ago. Latest data is always returned in time descending order.
         * @summary Latest data by symbol_id
         * @throws {RequiredError}
         */
        v1TradesSymbolIdLatestGet(symbolId: string, limit?: number, includeId?: boolean, options?: RequestOptions = {}): Promise<Array<V1Trade>> {
            const localVarFetchArgs = TradesApiFetchParamCreator(configuration).v1TradesSymbolIdLatestGet(symbolId, limit, includeId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    ExchangeRatesApi: ExchangeRatesApiType,

    ExternalMetricsApi: ExternalMetricsApiType,

    MetadataApi: MetadataApiType,

    MetricsApi: MetricsApiType,

    OhlcvApi: OhlcvApiType,

    OptionsApi: OptionsApiType,

    OrderBookApi: OrderBookApiType,

    OrderBookL3Api: OrderBookL3ApiType,

    QuotesApi: QuotesApiType,

    TradesApi: TradesApiType,
 }
