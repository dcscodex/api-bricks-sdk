/**
 * FX Realtime REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: support@apibricks.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import org.openapitools.client.ApiInvoker;
import org.openapitools.client.ApiException;
import org.openapitools.client.Pair;

import org.openapitools.client.model.*;

import java.util.*;

import com.android.volley.Response;
import com.android.volley.VolleyError;

import org.openapitools.client.model.V1ExchangeRate;
import org.openapitools.client.model.V1ExchangeRates;

import org.apache.http.HttpEntity;
import org.apache.http.entity.mime.MultipartEntityBuilder;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeoutException;

public class ExchangeRatesApi {
  String basePath = "https://api-realtime.fx.finfeedapi.com";
  ApiInvoker apiInvoker = ApiInvoker.getInstance();

  public void addHeader(String key, String value) {
    getInvoker().addDefaultHeader(key, value);
  }

  public ApiInvoker getInvoker() {
    return apiInvoker;
  }

  public void setBasePath(String basePath) {
    this.basePath = basePath;
  }

  public String getBasePath() {
    return basePath;
  }

  /**
  * Get specific rate
  * Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
   * @param assetIdBase Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)
   * @param assetIdQuote Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)
   * @return V1ExchangeRate
  */
  public V1ExchangeRate getSpecificRate (String assetIdBase, String assetIdQuote) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'assetIdBase' is set
    if (assetIdBase == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'assetIdBase' when calling getSpecificRate",
        new ApiException(400, "Missing the required parameter 'assetIdBase' when calling getSpecificRate"));
    }
    // verify the required parameter 'assetIdQuote' is set
    if (assetIdQuote == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'assetIdQuote' when calling getSpecificRate",
        new ApiException(400, "Missing the required parameter 'assetIdQuote' when calling getSpecificRate"));
    }

    // create path and map variables
    String path = "/v1/exchangerate/{asset_id_base}/{asset_id_quote}".replaceAll("\\{" + "asset_id_base" + "\\}", apiInvoker.escapeString(assetIdBase.toString())).replaceAll("\\{" + "asset_id_quote" + "\\}", apiInvoker.escapeString(assetIdQuote.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKey", "JWT" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (V1ExchangeRate) ApiInvoker.deserialize(localVarResponse, "", V1ExchangeRate.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get specific rate
   * Retrieves the exchange rate for a specific base and quote asset at a given time or the current rate.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::
   * @param assetIdBase Requested exchange rate base asset identifier (from the Metadata -&gt; Assets)   * @param assetIdQuote Requested exchange rate quote asset identifier (from the Metadata -&gt; Assets)
  */
  public void getSpecificRate (String assetIdBase, String assetIdQuote, final Response.Listener<V1ExchangeRate> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'assetIdBase' is set
    if (assetIdBase == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'assetIdBase' when calling getSpecificRate",
        new ApiException(400, "Missing the required parameter 'assetIdBase' when calling getSpecificRate"));
    }
    // verify the required parameter 'assetIdQuote' is set
    if (assetIdQuote == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'assetIdQuote' when calling getSpecificRate",
        new ApiException(400, "Missing the required parameter 'assetIdQuote' when calling getSpecificRate"));
    }

    // create path and map variables
    String path = "/v1/exchangerate/{asset_id_base}/{asset_id_quote}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "asset_id_base" + "\\}", apiInvoker.escapeString(assetIdBase.toString())).replaceAll("\\{" + "asset_id_quote" + "\\}", apiInvoker.escapeString(assetIdQuote.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();



    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKey", "JWT" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((V1ExchangeRate) ApiInvoker.deserialize(localVarResponse,  "", V1ExchangeRate.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
  /**
  * Get all current rates
  * Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
   * @param assetIdBase Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)
   * @param filterAssetId Comma or semicolon delimited asset identifiers used to filter response (optional)
   * @param invert True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;)
   * @return V1ExchangeRates
  */
  public V1ExchangeRates v1ExchangerateAssetIdBaseGet (String assetIdBase, String filterAssetId, Boolean invert) throws TimeoutException, ExecutionException, InterruptedException, ApiException {
    Object postBody = null;
    // verify the required parameter 'assetIdBase' is set
    if (assetIdBase == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'assetIdBase' when calling v1ExchangerateAssetIdBaseGet",
        new ApiException(400, "Missing the required parameter 'assetIdBase' when calling v1ExchangerateAssetIdBaseGet"));
    }

    // create path and map variables
    String path = "/v1/exchangerate/{asset_id_base}".replaceAll("\\{" + "asset_id_base" + "\\}", apiInvoker.escapeString(assetIdBase.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();
    queryParams.addAll(ApiInvoker.parameterToPairs("", "filter_asset_id", filterAssetId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "invert", invert));
    String[] contentTypes = {
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
    }

    String[] authNames = new String[] { "APIKey", "JWT" };

    try {
      String localVarResponse = apiInvoker.invokeAPI (basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames);
      if (localVarResponse != null) {
         return (V1ExchangeRates) ApiInvoker.deserialize(localVarResponse, "", V1ExchangeRates.class);
      } else {
         return null;
      }
    } catch (ApiException ex) {
       throw ex;
    } catch (InterruptedException ex) {
       throw ex;
    } catch (ExecutionException ex) {
      if (ex.getCause() instanceof VolleyError) {
        VolleyError volleyError = (VolleyError)ex.getCause();
        if (volleyError.networkResponse != null) {
          throw new ApiException(volleyError.networkResponse.statusCode, volleyError.getMessage());
        }
      }
      throw ex;
    } catch (TimeoutException ex) {
      throw ex;
    }
  }

      /**
   * Get all current rates
   * Get the current exchange rate between requested asset and all other assets.              :::info If you are using an exchange rate for mission-critical operations, then for best reliability, you should measure the difference between current time and the time returned from the response to ensure that value of the difference between those meets your internal requirements. :::              :::info You can invert the rates by using Y &#x3D; 1 / X equation, for example BTC/USD &#x3D; 1 / (USD/BTC); :::
   * @param assetIdBase Requested exchange rates base asset identifier (from the Metadata -&gt; Assets)   * @param filterAssetId Comma or semicolon delimited asset identifiers used to filter response (optional)   * @param invert True will invert all the rates (optional, if true then rates will be calculated as &#x60;rate &#x3D; 1 / actual_rate&#x60; eg. &#x60;USD/BTC&#x60; as &#x60;BTC/USD&#x60;)
  */
  public void v1ExchangerateAssetIdBaseGet (String assetIdBase, String filterAssetId, Boolean invert, final Response.Listener<V1ExchangeRates> responseListener, final Response.ErrorListener errorListener) {
    Object postBody = null;

    // verify the required parameter 'assetIdBase' is set
    if (assetIdBase == null) {
      VolleyError error = new VolleyError("Missing the required parameter 'assetIdBase' when calling v1ExchangerateAssetIdBaseGet",
        new ApiException(400, "Missing the required parameter 'assetIdBase' when calling v1ExchangerateAssetIdBaseGet"));
    }

    // create path and map variables
    String path = "/v1/exchangerate/{asset_id_base}".replaceAll("\\{format\\}","json").replaceAll("\\{" + "asset_id_base" + "\\}", apiInvoker.escapeString(assetIdBase.toString()));

    // query params
    List<Pair> queryParams = new ArrayList<Pair>();
    // header params
    Map<String, String> headerParams = new HashMap<String, String>();
    // form params
    Map<String, String> formParams = new HashMap<String, String>();

    queryParams.addAll(ApiInvoker.parameterToPairs("", "filter_asset_id", filterAssetId));
    queryParams.addAll(ApiInvoker.parameterToPairs("", "invert", invert));


    String[] contentTypes = {
      
    };
    String contentType = contentTypes.length > 0 ? contentTypes[0] : "application/json";

    if (contentType.startsWith("multipart/form-data")) {
      // file uploading
      MultipartEntityBuilder localVarBuilder = MultipartEntityBuilder.create();
      

      HttpEntity httpEntity = localVarBuilder.build();
      postBody = httpEntity;
    } else {
      // normal form params
          }

    String[] authNames = new String[] { "APIKey", "JWT" };

    try {
      apiInvoker.invokeAPI(basePath, path, "GET", queryParams, postBody, headerParams, formParams, contentType, authNames,
        new Response.Listener<String>() {
          @Override
          public void onResponse(String localVarResponse) {
            try {
              responseListener.onResponse((V1ExchangeRates) ApiInvoker.deserialize(localVarResponse,  "", V1ExchangeRates.class));
            } catch (ApiException exception) {
               errorListener.onErrorResponse(new VolleyError(exception));
            }
          }
      }, new Response.ErrorListener() {
          @Override
          public void onErrorResponse(VolleyError error) {
            errorListener.onErrorResponse(error);
          }
      });
    } catch (ApiException ex) {
      errorListener.onErrorResponse(new VolleyError(ex));
    }
  }
}
